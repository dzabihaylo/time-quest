---
phase: 01-playable-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TimeQuest/TimeQuest.xcodeproj
  - TimeQuest/App/TimeQuestApp.swift
  - TimeQuest/App/AppDependencies.swift
  - TimeQuest/App/RoleRouter.swift
  - TimeQuest/Models/Routine.swift
  - TimeQuest/Models/RoutineTask.swift
  - TimeQuest/Models/GameSession.swift
  - TimeQuest/Models/TaskEstimation.swift
  - TimeQuest/Repositories/RoutineRepository.swift
  - TimeQuest/Repositories/SessionRepository.swift
  - TimeQuest/Features/Shared/Views/PINEntryView.swift
  - TimeQuest/Features/Player/Views/PlayerHomeView.swift
  - TimeQuest/Features/Parent/Views/ParentDashboardView.swift
  - TimeQuest/Domain/TimeEstimationScorer.swift
  - TimeQuest/Domain/FeedbackGenerator.swift
  - TimeQuest/Domain/CalibrationTracker.swift
  - TimeQuest/Features/Shared/Components/TimeFormatting.swift
autonomous: true

must_haves:
  truths:
    - "App compiles and launches into player mode by default"
    - "Hidden gesture (triple-tap) on player home triggers PIN entry sheet"
    - "Correct PIN navigates to parent dashboard; incorrect PIN stays in player mode"
    - "Parent can exit back to player mode"
    - "All four SwiftData models persist across app launches"
  artifacts:
    - path: "TimeQuest/App/TimeQuestApp.swift"
      provides: "@main entry point with ModelContainer for all 4 model types"
      contains: "@main"
    - path: "TimeQuest/App/RoleRouter.swift"
      provides: "Player/parent mode switching with PIN gate"
      exports: ["RoleRouter", "RoleState", "AppRole"]
    - path: "TimeQuest/Models/Routine.swift"
      provides: "Routine SwiftData model with orderedTasks computed property"
      contains: "@Model"
    - path: "TimeQuest/Models/RoutineTask.swift"
      provides: "RoutineTask SwiftData model with orderIndex"
      contains: "@Model"
    - path: "TimeQuest/Models/GameSession.swift"
      provides: "GameSession SwiftData model with orderedEstimations"
      contains: "@Model"
    - path: "TimeQuest/Models/TaskEstimation.swift"
      provides: "TaskEstimation SwiftData model"
      contains: "@Model"
    - path: "TimeQuest/Repositories/RoutineRepository.swift"
      provides: "Protocol + SwiftData implementation for routine data access"
      exports: ["RoutineRepositoryProtocol", "SwiftDataRoutineRepository"]
    - path: "TimeQuest/Repositories/SessionRepository.swift"
      provides: "Protocol + SwiftData implementation for session data access"
      exports: ["SessionRepositoryProtocol", "SwiftDataSessionRepository"]
    - path: "TimeQuest/Domain/TimeEstimationScorer.swift"
      provides: "Pure scoring logic for estimation accuracy"
      exports: ["TimeEstimationScorer", "EstimationResult", "AccuracyRating"]
    - path: "TimeQuest/Domain/FeedbackGenerator.swift"
      provides: "Curiosity-framed feedback text generation"
      exports: ["FeedbackGenerator", "FeedbackMessage"]
    - path: "TimeQuest/Domain/CalibrationTracker.swift"
      provides: "Tracks whether a routine is in calibration phase"
      exports: ["CalibrationTracker"]
  key_links:
    - from: "TimeQuest/App/TimeQuestApp.swift"
      to: "TimeQuest/App/RoleRouter.swift"
      via: "Root view in WindowGroup"
      pattern: "RoleRouter\\(\\)"
    - from: "TimeQuest/App/TimeQuestApp.swift"
      to: "SwiftData ModelContainer"
      via: ".modelContainer modifier"
      pattern: "\\.modelContainer"
    - from: "TimeQuest/App/RoleRouter.swift"
      to: "TimeQuest/Features/Shared/Views/PINEntryView.swift"
      via: ".sheet presentation on PIN request"
      pattern: "\\.sheet.*PINEntryView"
    - from: "TimeQuest/Models/Routine.swift"
      to: "TimeQuest/Models/RoutineTask.swift"
      via: "@Relationship cascade with inverse"
      pattern: "@Relationship.*cascade.*RoutineTask"
---

<objective>
Create the Xcode project, all SwiftData models, repository protocols, pure domain logic engines, and the dual-mode app shell (player-default with hidden parent access via triple-tap + PIN).

Purpose: Establishes the entire data layer and app skeleton that Plans 02 and 03 build upon. Without this, no feature code has models to persist to or a shell to render in.

Output: A compilable, launchable iOS app that shows a placeholder player home screen, allows hidden-gesture access to a placeholder parent dashboard via PIN, and has all persistence models + domain logic ready for feature plans.
</objective>

<execution_context>
@/Users/davezabihaylo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davezabihaylo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-playable-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Xcode project, SwiftData models, repositories, and domain engines</name>
  <files>
    TimeQuest/TimeQuest.xcodeproj
    TimeQuest/App/TimeQuestApp.swift
    TimeQuest/App/AppDependencies.swift
    TimeQuest/Models/Routine.swift
    TimeQuest/Models/RoutineTask.swift
    TimeQuest/Models/GameSession.swift
    TimeQuest/Models/TaskEstimation.swift
    TimeQuest/Repositories/RoutineRepository.swift
    TimeQuest/Repositories/SessionRepository.swift
    TimeQuest/Domain/TimeEstimationScorer.swift
    TimeQuest/Domain/FeedbackGenerator.swift
    TimeQuest/Domain/CalibrationTracker.swift
    TimeQuest/Features/Shared/Components/TimeFormatting.swift
  </files>
  <action>
    **Create Xcode project:**
    Create a new iOS App project named "TimeQuest" at the repo root using `swift package init` is NOT suitable -- use Xcode project generation via command line or create the project structure manually with a Package.swift-free Xcode project. The simplest path: create the directory structure and files manually, then generate the .xcodeproj using `xcodegen` or create a minimal project file. Since this is greenfield, create files in `TimeQuest/` directory structure and use `xcodegen` (install via `brew install xcodegen` if needed) with a `project.yml` to generate the .xcodeproj.

    Alternative if xcodegen is unavailable: Create a Swift Package-based project structure. The key requirement is that `xcodebuild build` succeeds.

    **Xcode project settings:**
    - iOS deployment target: 17.0
    - Swift language version: 6.2 (or whatever the Xcode default is)
    - Bundle identifier: com.timequest.app (or similar)
    - Frameworks: SwiftUI, SwiftData, SpriteKit, CryptoKit (all system frameworks, no SPM packages)

    **SwiftData models (4 files in Models/):**
    Implement exactly as specified in RESEARCH.md patterns 2 and session data model:

    1. `Routine.swift`: @Model class with name, displayName, activeDays ([Int]), isActive (default true), createdAt, updatedAt, @Relationship(deleteRule: .cascade, inverse: \RoutineTask.routine) tasks, computed `orderedTasks`. Also @Relationship to sessions.

    2. `RoutineTask.swift`: @Model class with name, displayName, referenceDurationSeconds (Int?), orderIndex (Int), routine (Routine? -- inverse).

    3. `GameSession.swift`: @Model class with routine (Routine?), startedAt (Date), completedAt (Date?), isCalibration (Bool), @Relationship(deleteRule: .cascade, inverse: \TaskEstimation.session) estimations, computed `orderedEstimations`.

    4. `TaskEstimation.swift`: @Model class with taskDisplayName (String -- snapshot at play time), estimatedSeconds (Double), actualSeconds (Double), differenceSeconds (Double -- signed, positive = overestimate), accuracyPercent (Double), ratingRawValue (String -- AccuracyRating.rawValue for SwiftData compatibility), orderIndex (Int), recordedAt (Date), session (GameSession? -- inverse). Computed `rating` property.

    CRITICAL SwiftData patterns to follow (from research pitfalls):
    - Use explicit `orderIndex: Int` on RoutineTask and TaskEstimation -- SwiftData does NOT preserve array order
    - Declare explicit inverse relationships on BOTH sides
    - Do NOT set relationships in init() -- create objects, insert into context, THEN relate them
    - Store AccuracyRating as rawValue String (not enum directly) for SwiftData compatibility

    **Repository protocols + implementations (2 files in Repositories/):**
    Follow RESEARCH.md pattern 5.

    1. `RoutineRepository.swift`:
       - Protocol `RoutineRepositoryProtocol` with: fetchAll() -> [Routine], fetchActiveForToday() -> [Routine], save(_ routine: Routine) throws, delete(_ routine: Routine) throws
       - Class `SwiftDataRoutineRepository` implementing the protocol with ModelContext
       - fetchActiveForToday: fetch where isActive == true, then filter in Swift for activeDays containing today's weekday (cannot use predicate on Codable array -- pitfall 5)

    2. `SessionRepository.swift`:
       - Protocol `SessionRepositoryProtocol` with: createSession(for routine: Routine, isCalibration: Bool) -> GameSession, fetchSessions(for routine: Routine) -> [GameSession], fetchAllSessions() -> [GameSession], save() throws
       - Class `SwiftDataSessionRepository` implementing the protocol

    **Domain engines (4 files in Domain/ and Shared/Components/):**
    Pure Swift -- NO SwiftUI or SwiftData imports. Foundation only.

    1. `TimeEstimationScorer.swift`: Exactly as in RESEARCH.md pattern 4. Struct with static `score(estimated:actual:) -> EstimationResult`. AccuracyRating enum (.spot_on, .close, .off, .way_off) with thresholds: spot_on = within max(15s, 10%), close = within 25%, off = within 50%, way_off = beyond 50%. For tasks < 60s, use absolute threshold scaled to 60s.

    2. `FeedbackGenerator.swift`: Exactly as in RESEARCH.md code example. Struct with static `message(for:isCalibrationPhase:) -> FeedbackMessage`. Non-punitive, curiosity-framed. Large gaps are "discoveries." Calibration phase gets special messaging ("Just learning your patterns"). Uses SF Symbol names for emoji field.

    3. `CalibrationTracker.swift`: Struct with static `isCalibrationSession(completedSessionCount: Int) -> Bool`. Returns true if completedSessionCount < 3. Calibration is per-routine (caller passes count for the specific routine). Also: `calibrationSessionsRemaining(completedSessionCount: Int) -> Int` returns max(0, 3 - completedSessionCount).

    4. `TimeFormatting.swift` (in Features/Shared/Components/): Utility for formatting durations. Use `DateComponentsFormatter` or manual formatting. Functions: `formatDuration(_ seconds: TimeInterval) -> String` (returns "2m 30s" style), `formatDurationLong(_ seconds: TimeInterval) -> String` (returns "2 minutes 30 seconds" style for accessibility).

    **AppDependencies.swift (composition root):**
    An @Observable class that creates and holds repository instances given a ModelContext. Views access repositories through this. Pattern:
    ```
    @Observable final class AppDependencies {
        let routineRepository: RoutineRepositoryProtocol
        let sessionRepository: SessionRepositoryProtocol
        init(modelContext: ModelContext) { ... }
    }
    ```
  </action>
  <verify>
    Run `xcodebuild build -project TimeQuest/TimeQuest.xcodeproj -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' 2>&1 | tail -5` (or equivalent build command for the project structure chosen). Build must succeed with zero errors.

    If using xcodegen: `cd TimeQuest && xcodegen generate && xcodebuild build ...`
  </verify>
  <done>
    All 4 SwiftData models compile with @Model macro, explicit orderIndex properties, and correct inverse relationships. Both repository protocols exist with SwiftData implementations. All 3 domain engines are pure Swift with no framework imports. AppDependencies composition root compiles. Project builds successfully targeting iOS 17.
  </done>
</task>

<task type="auto">
  <name>Task 2: Dual-mode app shell with RoleRouter, PIN gate, and placeholder views</name>
  <files>
    TimeQuest/App/RoleRouter.swift
    TimeQuest/App/TimeQuestApp.swift
    TimeQuest/Features/Shared/Views/PINEntryView.swift
    TimeQuest/Features/Player/Views/PlayerHomeView.swift
    TimeQuest/Features/Parent/Views/ParentDashboardView.swift
  </files>
  <action>
    **RoleRouter.swift:**
    Implement exactly as in RESEARCH.md pattern 1.
    - `AppRole` enum: .player, .parent
    - `RoleState` @Observable class: currentRole (default .player), showingPINEntry (Bool), methods requestParentAccess(), grantParentAccess(), exitParentMode()
    - `RoleRouter` View: switches on currentRole to show PlayerHomeView or ParentDashboardView. Sheet for PINEntryView on showingPINEntry. Pass roleState via .environment().

    **PINEntryView.swift:**
    - 4-digit PIN entry using a grid of number buttons (0-9) and a display showing dots for entered digits
    - On first launch (no PIN set yet), show "Set a PIN" mode: enter PIN, confirm PIN, hash with SHA-256 (CryptoKit), store hash in UserDefaults key "parentPINHash"
    - On subsequent access, show "Enter PIN" mode: enter PIN, hash input, compare to stored hash
    - On success: call onSuccess callback (which triggers roleState.grantParentAccess)
    - On failure: shake animation on the dots, clear input, let user retry. No lockout for v1.
    - Visual design: clean, minimal. No "parent" or "admin" language -- just dots and numbers. Could use a neutral prompt like "Enter code" (not "Parent PIN").
    - Use `import CryptoKit` and `SHA256.hash(data:)` for hashing. Convert PIN string to Data, hash, convert to hex string for storage/comparison.

    **PlayerHomeView.swift (placeholder):**
    - Shows app title "TimeQuest" (or a placeholder logo area) and text like "No quests available" (will be replaced in Plan 03)
    - CRITICAL: Attach hidden gesture to the title/logo area: `.onTapGesture(count: 3) { roleState.requestParentAccess() }` -- this is the ONLY way to access parent mode. No visible button, no settings icon, nothing.
    - Access roleState from environment
    - Zero parent-facing language anywhere (FOUN-03). No "settings", "admin", "parent", "locked" text.

    **ParentDashboardView.swift (placeholder):**
    - Shows "Setup" as title and a placeholder message like "Routines will appear here" (will be replaced in Plan 02)
    - Has a "Done" or "Exit" button that calls roleState.exitParentMode() to return to player mode
    - This IS the parent-facing view, so parent language is fine here ("Routines", "Setup")

    **TimeQuestApp.swift updates:**
    - @main struct with WindowGroup containing RoleRouter()
    - .modelContainer(for: [Routine.self, RoutineTask.self, GameSession.self, TaskEstimation.self])
    - Create AppDependencies in RoleRouter or TimeQuestApp and pass via .environment()

    **Testing the full flow:**
    After building, the app should: launch -> show PlayerHomeView -> triple-tap title -> PIN sheet appears -> set PIN (first time) or enter PIN -> correct = ParentDashboardView -> tap Done -> back to PlayerHomeView.
  </action>
  <verify>
    Run the full build: `xcodebuild build -project TimeQuest/TimeQuest.xcodeproj -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' 2>&1 | tail -10`. Must succeed.

    Verify no parent language in player view: grep the PlayerHomeView.swift file for words "parent", "admin", "settings", "locked", "PIN" -- none should appear in user-visible strings.
  </verify>
  <done>
    App launches into PlayerHomeView (player mode default -- FOUN-01). Triple-tap on title area triggers PIN entry sheet (FOUN-02). First launch allows setting a PIN; subsequent launches require the PIN. Correct PIN shows ParentDashboardView. "Done" returns to player mode. PlayerHomeView contains zero parent-facing language (FOUN-03). PIN is SHA-256 hashed, never stored in plaintext.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with zero errors for iOS 17 simulator target
2. All @Model classes have explicit orderIndex where needed and correct @Relationship inverses
3. Repository protocols exist separately from SwiftData implementations
4. Domain engines (Scorer, FeedbackGenerator, CalibrationTracker) import only Foundation -- no SwiftUI/SwiftData
5. RoleRouter defaults to .player on launch
6. Triple-tap gesture triggers PIN sheet
7. PIN hashed with SHA-256, stored in UserDefaults
8. No "parent", "admin", "settings", "locked" strings visible in player-facing views
</verification>

<success_criteria>
- App compiles and can be launched on iOS 17+ simulator
- Player mode is the default on every app launch (FOUN-01)
- Hidden gesture + PIN gate works for parent access (FOUN-02)
- Zero parent evidence in player UI (FOUN-03)
- SwiftData ModelContainer configured for all 4 model types (FOUN-04)
- iOS 17+ target set (FOUN-05)
- Pure domain engines ready for Plan 03 gameplay integration
- Repository protocols ready for Plan 02 CRUD operations
</success_criteria>

<output>
After completion, create `.planning/phases/01-playable-foundation/01-01-SUMMARY.md`
</output>

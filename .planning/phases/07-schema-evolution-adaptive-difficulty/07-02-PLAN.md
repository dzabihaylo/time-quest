---
phase: 07-schema-evolution-adaptive-difficulty
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - TimeQuest/Domain/AdaptiveDifficultyEngine.swift
  - TimeQuest/Domain/TimeEstimationScorer.swift
  - TimeQuest/Domain/XPEngine.swift
  - TimeQuest/Features/Player/ViewModels/GameSessionViewModel.swift
  - TimeQuest/Tests/AdaptiveDifficultyEngineTests.swift
  - generate-xcodeproj.js
autonomous: true

must_haves:
  truths:
    - "Player who consistently estimates accurately sees accuracy thresholds tighten over subsequent sessions for that task"
    - "Player having a rough streak never sees difficulty decrease -- the game holds steady or progresses"
    - "Player sees no UI indication that difficulty exists -- no labels, no notifications, no settings"
    - "Player at higher difficulty earns noticeably more XP per quest than at starting level for equivalent accuracy"
    - "Historical accuracy comparisons in insights and charts remain fair -- accuracyPercent is difficulty-independent"
    - "Difficulty state (EMA and level) is not updated during calibration sessions -- the entire difficulty update block is guarded by !isCalibration"
  artifacts:
    - path: "TimeQuest/Domain/AdaptiveDifficultyEngine.swift"
      provides: "Pure Foundation engine for EMA, monotonic difficulty level, thresholds, XP multiplier"
      contains: "struct AdaptiveDifficultyEngine"
    - path: "TimeQuest/Domain/TimeEstimationScorer.swift"
      provides: "Threshold-parameterized scoring -- AccuracyThresholds injected, accuracyPercent stays pure"
      contains: "thresholds: AccuracyThresholds"
    - path: "TimeQuest/Domain/XPEngine.swift"
      provides: "Difficulty-scaled XP via multiplier parameter"
      contains: "difficultyLevel: Int"
    - path: "TimeQuest/Features/Player/ViewModels/GameSessionViewModel.swift"
      provides: "Full adaptive difficulty flow in completeActiveTask: fetch state, score with thresholds, update EMA, ratchet level, stamp session"
      contains: "AdaptiveDifficultyEngine"
    - path: "TimeQuest/Tests/AdaptiveDifficultyEngineTests.swift"
      provides: "Comprehensive unit tests for EMA, monotonic ratchet, minimum sessions guard, threshold lookup, XP multiplier"
      contains: "final class AdaptiveDifficultyEngineTests"
  key_links:
    - from: "GameSessionViewModel.completeActiveTask()"
      to: "AdaptiveDifficultyEngine"
      via: "fetch difficulty state, compute thresholds, update EMA, ratchet level"
      pattern: "AdaptiveDifficultyEngine\\.updatedEMA"
    - from: "GameSessionViewModel.completeActiveTask()"
      to: "TimeEstimationScorer.score"
      via: "passes difficulty-appropriate thresholds"
      pattern: "TimeEstimationScorer\\.score.*thresholds"
    - from: "GameSessionViewModel.advanceToNextTask()"
      to: "XPEngine.xpForSession"
      via: "passes difficulty level for multiplied XP"
      pattern: "XPEngine\\.xpForSession.*difficultyLevel"
    - from: "AdaptiveDifficultyEngine.difficultyLevel()"
      to: "monotonic ratchet"
      via: "max(currentLevel, computed)"
      pattern: "max\\(currentLevel"
---

# Plan 07-02: Adaptive Difficulty Engine + Game Flow Integration

## Goal

Create the AdaptiveDifficultyEngine and wire it into the live game flow so that scoring, XP rewards, and session metadata all respond to the player's per-task performance level. After this plan, the game invisibly adapts: accuracy thresholds tighten as the player improves, XP scales with earned challenge, and each session records its context for fair historical comparison.

## Prerequisites

- **Plan 07-01 complete**: SchemaV4, migration, typealiases, DifficultyConfiguration, DifficultySnapshot, TimeQuestApp updated, build passing
- Research: `.planning/phases/07-schema-evolution-adaptive-difficulty/07-RESEARCH.md`

## Requirements Covered

- **DIFF-01**: Game automatically adjusts estimation accuracy thresholds per task based on historical performance
- **DIFF-02**: Difficulty only progresses or holds -- never decreases (monotonic ratchet)
- **DIFF-03**: Difficulty adjustment is completely invisible to the player
- **DIFF-04**: XP rewards scale with difficulty level (1.0x to 2.0x)
- **DIFF-05**: Session stores difficultyLevel and xpMultiplier; accuracyPercent remains difficulty-independent

<objective>
Create the AdaptiveDifficultyEngine and wire it into the game loop so the game invisibly adapts to the player's improving skill.

Purpose: Connect the data foundation from Plan 07-01 (V4 schema, configuration, snapshot types) into the actual gameplay. The engine computes EMA and difficulty levels; the scorer accepts per-level thresholds; XPEngine applies multipliers; GameSessionViewModel orchestrates the full flow per estimation.

Output: AdaptiveDifficultyEngine (pure Foundation), updated TimeEstimationScorer (threshold-parameterized), updated XPEngine (difficulty-multiplied), updated GameSessionViewModel (full adaptive flow), comprehensive unit tests, updated generate-xcodeproj.js, successful build.
</objective>

<execution_context>
@/Users/davezabihaylo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davezabihaylo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-schema-evolution-adaptive-difficulty/07-RESEARCH.md
@.planning/phases/07-schema-evolution-adaptive-difficulty/07-01-SUMMARY.md
@TimeQuest/Domain/TimeEstimationScorer.swift
@TimeQuest/Domain/XPEngine.swift
@TimeQuest/Domain/XPConfiguration.swift
@TimeQuest/Domain/CalibrationTracker.swift
@TimeQuest/Features/Player/ViewModels/GameSessionViewModel.swift
@generate-xcodeproj.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AdaptiveDifficultyEngine and update TimeEstimationScorer and XPEngine</name>
  <files>
    TimeQuest/Domain/AdaptiveDifficultyEngine.swift
    TimeQuest/Domain/TimeEstimationScorer.swift
    TimeQuest/Domain/XPEngine.swift
  </files>
  <action>
    **Create `TimeQuest/Domain/AdaptiveDifficultyEngine.swift`:**

    Follow the InsightEngine/WeeklyReflectionEngine pattern: Foundation only, struct with static methods, no SwiftData import.

    ```swift
    import Foundation

    struct AdaptiveDifficultyEngine {
        /// Compute updated EMA from current accuracy and previous EMA.
        /// EMA = (accuracy * alpha) + (previousEMA * (1 - alpha))
        static func updatedEMA(
            currentAccuracy: Double,
            previousEMA: Double,
            alpha: Double = DifficultyConfiguration.default.emaAlpha
        ) -> Double {
            (currentAccuracy * alpha) + (previousEMA * (1.0 - alpha))
        }

        /// Determine the difficulty level for a task based on its EMA.
        /// Monotonic: returns max(currentLevel, computed level) -- NEVER decreases (DIFF-02).
        /// Requires minimum total estimations before allowing advancement past level 1.
        static func difficultyLevel(
            ema: Double,
            currentLevel: Int,
            totalEstimations: Int,
            config: DifficultyConfiguration = .default
        ) -> Int {
            // Cannot advance beyond level 1 until minimum estimations completed
            guard totalEstimations >= config.minimumSessionsToAdvance else {
                return max(1, currentLevel)
            }
            let computed = config.levelForEMA(ema)
            return max(currentLevel, computed)  // DIFF-02: never decrease
        }

        /// Get accuracy thresholds for a given difficulty level.
        static func thresholds(
            forLevel level: Int,
            config: DifficultyConfiguration = .default
        ) -> AccuracyThresholds {
            config.thresholds(forLevel: level)
        }

        /// XP multiplier for a given difficulty level.
        static func xpMultiplier(
            forLevel level: Int,
            config: DifficultyConfiguration = .default
        ) -> Double {
            config.xpMultiplier(forLevel: level)
        }
    }
    ```

    The `totalEstimations` parameter in `difficultyLevel()` is critical: it enforces the minimum-sessions guard so a lucky early streak cannot prematurely tighten accuracy bands. The caller passes the total count of completed estimations for that task name.

    **Update `TimeQuest/Domain/TimeEstimationScorer.swift`:**

    Add an `AccuracyThresholds` parameter with a default value so all existing callers continue to work unchanged:

    ```swift
    static func score(
        estimated: TimeInterval,
        actual: TimeInterval,
        thresholds: AccuracyThresholds = DifficultyConfiguration.default.thresholds(forLevel: 1)
    ) -> EstimationResult {
    ```

    Replace the hardcoded threshold values in the rating logic:
    - `max(15, actual * 0.10)` becomes `max(DifficultyConfiguration.default.minimumAbsoluteThresholdSeconds, actual * thresholds.spotOn)`
    - `actual * 0.25` becomes `actual * thresholds.close`
    - `actual * 0.50` becomes `actual * thresholds.off`

    Do NOT change the `accuracy` (accuracyPercent) calculation. It MUST remain the pure mathematical measure: `100 - (absDiff / actual * 100)` for tasks >= 60s, `100 - (absDiff / 60 * 100)` for short tasks. Only the RATING changes based on difficulty thresholds. This is the single most important architectural constraint -- accuracyPercent being difficulty-independent is what keeps all charts, insights, and historical comparisons fair (DIFF-05).

    Keep `EstimationResult` and `AccuracyRating` definitions unchanged.

    **Update `TimeQuest/Domain/XPEngine.swift`:**

    Add a `difficultyLevel` parameter with default `1` to both methods:

    ```swift
    static func xpForEstimation(rating: AccuracyRating, difficultyLevel: Int = 1) -> Int {
        let base: Int
        switch rating {
        case .spot_on: base = configuration.spotOnXP
        case .close:   base = configuration.closeXP
        case .off:     base = configuration.offXP
        case .way_off: base = configuration.wayOffXP
        }
        let multiplier = DifficultyConfiguration.default.xpMultiplier(forLevel: difficultyLevel)
        return Int(Double(base) * multiplier)
    }

    static func xpForSession(estimations: [TaskEstimation], difficultyLevel: Int = 1) -> Int {
        let taskXP = estimations.reduce(0) { $0 + xpForEstimation(rating: $1.rating, difficultyLevel: difficultyLevel) }
        return taskXP + configuration.completionBonus
    }
    ```

    The completion bonus is NOT multiplied -- only per-estimation XP scales with difficulty. Default parameter `difficultyLevel: 1` ensures all existing callers get baseline behavior unchanged.

    **Critical constraints:**
    - AdaptiveDifficultyEngine must NOT import SwiftData -- Foundation only
    - Do NOT modify the accuracyPercent calculation in TimeEstimationScorer
    - Do NOT multiply the completion bonus in XPEngine
    - Default parameters ensure backward compatibility -- no other callers need changes
    - The `difficultyLevel()` method MUST use `max(currentLevel, computed)` to enforce the monotonic ratchet
    - The `difficultyLevel()` method MUST check `totalEstimations >= minimumSessionsToAdvance` before allowing advancement past level 1
  </action>
  <verify>
    1. Grep for `import SwiftData` in AdaptiveDifficultyEngine.swift -- should find 0 matches
    2. Grep for `max(currentLevel` in AdaptiveDifficultyEngine.swift -- should find 1 match (monotonic ratchet)
    3. Grep for `minimumSessionsToAdvance` in AdaptiveDifficultyEngine.swift -- should find 1 match (guard clause)
    4. Grep for `thresholds: AccuracyThresholds` in TimeEstimationScorer.swift -- should find 1 match
    5. Grep for `actual \* 0\.10` in TimeEstimationScorer.swift -- should find 0 matches (replaced with thresholds.spotOn)
    6. Grep for `actual \* 0\.25` in TimeEstimationScorer.swift -- should find 0 matches (replaced with thresholds.close)
    7. Grep for `difficultyLevel: Int` in XPEngine.swift -- should find 2 matches (both methods)
    8. Grep for `completionBonus` in XPEngine.swift -- verify it is NOT multiplied (just added at end)
  </verify>
  <done>
    AdaptiveDifficultyEngine is a pure Foundation struct with EMA computation, monotonic difficulty ratchet with minimum-sessions guard, threshold lookup, and XP multiplier. TimeEstimationScorer accepts AccuracyThresholds parameter (default=Level 1 for backward compat), accuracyPercent untouched. XPEngine multiplies per-estimation XP by difficulty multiplier, completion bonus unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire adaptive difficulty into GameSessionViewModel, add tests, and register files</name>
  <files>
    TimeQuest/Features/Player/ViewModels/GameSessionViewModel.swift
    TimeQuest/Tests/AdaptiveDifficultyEngineTests.swift
    generate-xcodeproj.js
  </files>
  <action>
    **Update `TimeQuest/Features/Player/ViewModels/GameSessionViewModel.swift`:**

    This is the primary integration point. Modify `completeActiveTask()` to use difficulty-appropriate thresholds and update difficulty state after each estimation. Also modify `advanceToNextTask()` to apply XP multiplier.

    1. Add a private stored property to track the maximum difficulty level seen during the session:
       ```swift
       private var sessionMaxDifficultyLevel: Int = 1
       ```

    2. Add a private helper method to fetch or create TaskDifficultyState (follows the PlayerProfileRepository.fetchOrCreate pattern):
       ```swift
       private func fetchOrCreateDifficultyState(for taskDisplayName: String) -> TaskDifficultyState {
           let descriptor = FetchDescriptor<TaskDifficultyState>(
               predicate: #Predicate { $0.taskDisplayName == taskDisplayName }
           )
           if let existing = (try? modelContext.fetch(descriptor))?.first {
               return existing
           }
           let state = TaskDifficultyState(taskDisplayName: taskDisplayName)
           modelContext.insert(state)
           return state
       }
       ```

    3. Add a private helper to count total completed estimations for a task name (for the minimum-sessions guard):
       ```swift
       private func totalEstimationsCount(for taskDisplayName: String) -> Int {
           let descriptor = FetchDescriptor<TaskEstimation>(
               predicate: #Predicate { $0.taskDisplayName == taskDisplayName }
           )
           return (try? modelContext.fetchCount(descriptor)) ?? 0
       }
       ```

    4. Modify `completeActiveTask()` (currently around line 188). The full updated method body:

       **Before the scoring call, fetch difficulty state and get thresholds:**
       ```swift
       // Fetch difficulty state for this task
       let diffState = fetchOrCreateDifficultyState(for: task.displayName)
       let thresholds = AdaptiveDifficultyEngine.thresholds(forLevel: diffState.difficultyLevel)
       ```

       **Update the scoring call** to pass thresholds:
       ```swift
       let result = TimeEstimationScorer.score(
           estimated: pendingEstimatedSeconds,
           actual: actualSeconds,
           thresholds: thresholds
       )
       ```

       **After persisting the estimation and the `try? modelContext.save()`, update difficulty state (skip during calibration):**
       ```swift
       // Update difficulty state (skip during calibration sessions)
       if !isCalibration {
           let newEMA = AdaptiveDifficultyEngine.updatedEMA(
               currentAccuracy: result.accuracyPercent,
               previousEMA: diffState.ema
           )
           let totalEstimations = totalEstimationsCount(for: task.displayName)
           let newLevel = AdaptiveDifficultyEngine.difficultyLevel(
               ema: newEMA,
               currentLevel: diffState.difficultyLevel,
               totalEstimations: totalEstimations
           )

           diffState.ema = newEMA
           if newLevel > diffState.difficultyLevel {
               diffState.difficultyLevel = newLevel
               diffState.sessionsAtCurrentLevel = 0
           } else {
               diffState.sessionsAtCurrentLevel += 1
           }
           diffState.lastUpdated = completedAt
       }

       sessionMaxDifficultyLevel = max(sessionMaxDifficultyLevel, diffState.difficultyLevel)

       try? modelContext.save()
       ```

       The `isCalibration` check ensures difficulty state (EMA, level) is NOT updated during calibration sessions. This prevents advancement even when a task appears across multiple routines where it could have >5 total estimations but still be in calibration for the current routine.

       Note: the existing `try? modelContext.save()` that saves the estimation should remain. Add a second save after updating difficulty state, or move the save to after both operations. The simplest approach: keep one save after the estimation insert, add another after the difficulty state update. SwiftData handles this fine.

    5. Modify `advanceToNextTask()` -- when all tasks are done (the else branch where `nextIndex >= totalTasks`):

       **Replace the existing XP calculation:**
       ```swift
       let xp = XPEngine.xpForSession(
           estimations: session.orderedEstimations,
           difficultyLevel: sessionMaxDifficultyLevel
       )
       session.xpEarned = xp
       session.difficultyLevel = sessionMaxDifficultyLevel
       session.xpMultiplier = AdaptiveDifficultyEngine.xpMultiplier(
           forLevel: sessionMaxDifficultyLevel
       )
       ```
       Keep all remaining logic (profile XP update, level-up check, streak update) exactly as is.

    6. Note: `completeActiveTask()` tracks the max difficulty level via `sessionMaxDifficultyLevel` but does NOT stamp the session â€” that happens in `advanceToNextTask()` (step 5 above). The session is only stamped once, after all tasks complete.

    7. In `finishQuest()`, add reset:
       ```swift
       sessionMaxDifficultyLevel = 1
       ```

    **IMPORTANT: Do NOT modify `completeTask()`** (the older method around line 128). Only modify `completeActiveTask()` which is the method called during live gameplay.

    **CalibrationTracker interaction:** The `if !isCalibration` guard wraps the entire difficulty update block, so during calibration sessions EMA and difficulty state are NOT updated at all. This prevents advancement even when a task appears across multiple routines.

    **Create `TimeQuest/Tests/AdaptiveDifficultyEngineTests.swift`:**

    Comprehensive unit tests for the pure engine (no SwiftData needed since it's Foundation-only):

    ```swift
    import XCTest
    @testable import TimeQuest

    final class AdaptiveDifficultyEngineTests: XCTestCase {

        // MARK: - EMA Tests

        func testEMAFromZero() {
            let ema = AdaptiveDifficultyEngine.updatedEMA(
                currentAccuracy: 80.0,
                previousEMA: 0.0
            )
            XCTAssertEqual(ema, 24.0, accuracy: 0.01)
            // (80 * 0.3) + (0 * 0.7) = 24.0
        }

        func testEMAConverges() {
            var ema = 0.0
            for _ in 0..<20 {
                ema = AdaptiveDifficultyEngine.updatedEMA(
                    currentAccuracy: 80.0,
                    previousEMA: ema
                )
            }
            // After many iterations of constant input, EMA should converge to that input
            XCTAssertEqual(ema, 80.0, accuracy: 1.0)
        }

        func testEMAWeightsRecentMore() {
            // Start with EMA of 50, get a 90
            let ema = AdaptiveDifficultyEngine.updatedEMA(
                currentAccuracy: 90.0,
                previousEMA: 50.0
            )
            // (90 * 0.3) + (50 * 0.7) = 27 + 35 = 62
            XCTAssertEqual(ema, 62.0, accuracy: 0.01)
        }

        // MARK: - Difficulty Level Tests

        func testStartsAtLevel1() {
            let level = AdaptiveDifficultyEngine.difficultyLevel(
                ema: 0.0,
                currentLevel: 1,
                totalEstimations: 0
            )
            XCTAssertEqual(level, 1)
        }

        func testCannotAdvanceBelowMinimumSessions() {
            // EMA of 90 would normally be level 5, but only 3 estimations
            let level = AdaptiveDifficultyEngine.difficultyLevel(
                ema: 90.0,
                currentLevel: 1,
                totalEstimations: 3
            )
            XCTAssertEqual(level, 1)
        }

        func testAdvancesAtMinimumSessions() {
            let level = AdaptiveDifficultyEngine.difficultyLevel(
                ema: 70.0,
                currentLevel: 1,
                totalEstimations: 5
            )
            XCTAssertEqual(level, 2)  // EMA 70 >= 65 threshold
        }

        func testMonotonicRatchetNeverDecreases() {
            // Player is at level 3 but EMA drops to 50 (below level 2 threshold)
            let level = AdaptiveDifficultyEngine.difficultyLevel(
                ema: 50.0,
                currentLevel: 3,
                totalEstimations: 20
            )
            XCTAssertEqual(level, 3)  // max(3, 1) = 3, NEVER decrease
        }

        func testAdvancesToLevel5() {
            let level = AdaptiveDifficultyEngine.difficultyLevel(
                ema: 92.0,
                currentLevel: 4,
                totalEstimations: 50
            )
            XCTAssertEqual(level, 5)  // EMA 92 >= 90 threshold
        }

        func testHoldsAtCurrentLevelWhenEMAInsufficient() {
            let level = AdaptiveDifficultyEngine.difficultyLevel(
                ema: 74.0,
                currentLevel: 2,
                totalEstimations: 15
            )
            XCTAssertEqual(level, 2)  // EMA 74 < 75, stays at level 2
        }

        // MARK: - Threshold Tests

        func testLevel1Thresholds() {
            let t = AdaptiveDifficultyEngine.thresholds(forLevel: 1)
            XCTAssertEqual(t.spotOn, 0.10, accuracy: 0.001)
            XCTAssertEqual(t.close, 0.25, accuracy: 0.001)
            XCTAssertEqual(t.off, 0.50, accuracy: 0.001)
        }

        func testLevel5ThresholdsTighter() {
            let t = AdaptiveDifficultyEngine.thresholds(forLevel: 5)
            XCTAssertEqual(t.spotOn, 0.04, accuracy: 0.001)
            XCTAssertEqual(t.close, 0.10, accuracy: 0.001)
            XCTAssertEqual(t.off, 0.25, accuracy: 0.001)
        }

        func testOutOfBoundsLevelClamps() {
            // Level 0 should clamp to level 1 thresholds
            let t0 = AdaptiveDifficultyEngine.thresholds(forLevel: 0)
            let t1 = AdaptiveDifficultyEngine.thresholds(forLevel: 1)
            XCTAssertEqual(t0.spotOn, t1.spotOn)

            // Level 99 should clamp to level 5 thresholds
            let t99 = AdaptiveDifficultyEngine.thresholds(forLevel: 99)
            let t5 = AdaptiveDifficultyEngine.thresholds(forLevel: 5)
            XCTAssertEqual(t99.spotOn, t5.spotOn)
        }

        // MARK: - XP Multiplier Tests

        func testLevel1Baseline() {
            let mult = AdaptiveDifficultyEngine.xpMultiplier(forLevel: 1)
            XCTAssertEqual(mult, 1.0, accuracy: 0.001)
        }

        func testLevel5DoubleXP() {
            let mult = AdaptiveDifficultyEngine.xpMultiplier(forLevel: 5)
            XCTAssertEqual(mult, 2.0, accuracy: 0.001)
        }

        func testXPMultiplierIncreases() {
            var previous = 0.0
            for level in 1...5 {
                let mult = AdaptiveDifficultyEngine.xpMultiplier(forLevel: level)
                XCTAssertGreaterThan(mult, previous, "Level \(level) multiplier should exceed level \(level - 1)")
                previous = mult
            }
        }

        // MARK: - Full Flow Simulation

        func testEMABuildupThroughCalibrationAndAdvancement() {
            var ema = 0.0
            var level = 1
            let accuracies = [60.0, 65.0, 70.0, 72.0, 75.0, 80.0, 85.0, 82.0, 88.0, 90.0]

            for (i, accuracy) in accuracies.enumerated() {
                ema = AdaptiveDifficultyEngine.updatedEMA(
                    currentAccuracy: accuracy,
                    previousEMA: ema
                )
                level = AdaptiveDifficultyEngine.difficultyLevel(
                    ema: ema,
                    currentLevel: level,
                    totalEstimations: i + 1
                )
            }

            // After 10 sessions of improving accuracy, should have advanced past level 1
            XCTAssertGreaterThan(level, 1, "Should advance past level 1 after consistent good performance")
            // Level should never exceed what EMA supports
            XCTAssertLessThanOrEqual(level, 5)
        }

        func testBadStreakDoesNotDecreaseDifficulty() {
            var ema = 75.0  // Established good EMA
            var level = 3

            // Simulate 5 bad sessions
            for _ in 0..<5 {
                ema = AdaptiveDifficultyEngine.updatedEMA(
                    currentAccuracy: 30.0,
                    previousEMA: ema
                )
                level = AdaptiveDifficultyEngine.difficultyLevel(
                    ema: ema,
                    currentLevel: level,
                    totalEstimations: 30
                )
            }

            XCTAssertEqual(level, 3, "Level must NEVER decrease, even after bad streak")
            XCTAssertLessThan(ema, 75.0, "EMA should drop though")
        }
    }
    ```

    **Update `generate-xcodeproj.js`:**

    Add 1 new source file entry to the `sourceFiles` array:
    ```javascript
    { name: 'AdaptiveDifficultyEngine.swift', path: 'Domain/AdaptiveDifficultyEngine.swift' },
    ```

    Add to the 'Domain' group files array in the `groups` array.

    Note: AdaptiveDifficultyEngineTests.swift is in the Tests directory which is not wired into the main build target. Create the test file anyway -- it follows the existing pattern of tests being written but not yet in the build system.

    After editing, run the script to regenerate the pbxproj:
    ```bash
    cd /Users/davezabihaylo/Desktop/Claude\ Cowork/GSD && node generate-xcodeproj.js
    ```

    Then verify the build compiles:
    ```bash
    cd /Users/davezabihaylo/Desktop/Claude\ Cowork/GSD/TimeQuest && xcodebuild -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20
    ```

    **Critical constraints:**
    - GameSessionViewModel already has `modelContext` -- use it for TaskDifficultyState fetch/create
    - The `#Predicate` closure for TaskDifficultyState uses `$0.taskDisplayName == taskDisplayName` (fetch-and-filter, no unique constraint)
    - During calibration sessions (`isCalibration == true`), EMA and difficulty state are NOT updated at all -- the `if !isCalibration` guard wraps the entire difficulty update block. This prevents advancement even when a task appears across multiple routines
    - No string containing "difficulty" should appear in any View file as player-facing text
    - The session's `difficultyLevel` is the MAX across all tasks in that session (tasks may be at different levels)
    - Do NOT modify `completeTask()` (the older unused method). Only modify `completeActiveTask()`
    - Do NOT add any player-facing UI changes -- no labels, no notifications, no settings related to the difficulty system
  </action>
  <verify>
    1. Grep for `import SwiftData` in AdaptiveDifficultyEngine.swift -- should find 0 matches
    2. Grep for `max(currentLevel` in AdaptiveDifficultyEngine.swift -- should find 1 match (monotonic ratchet)
    3. Grep for `AdaptiveDifficultyEngine` in GameSessionViewModel.swift -- should find multiple matches
    4. Grep for `fetchOrCreateDifficultyState` in GameSessionViewModel.swift -- should find 2 matches (definition + call)
    5. Grep for `sessionMaxDifficultyLevel` in GameSessionViewModel.swift -- should find matches (declaration, update, usage, reset)
    6. Grep for `session.difficultyLevel` in GameSessionViewModel.swift -- should find 1 match (stamping in advanceToNextTask)
    7. Grep for `session.xpMultiplier` in GameSessionViewModel.swift -- should find 1 match (stamping in advanceToNextTask)
    8. Grep for `AdaptiveDifficultyEngine.swift` in generate-xcodeproj.js -- should find matches
    9. Run `node generate-xcodeproj.js` -- should complete without errors
    10. Run `xcodebuild -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build` -- should succeed (BUILD SUCCEEDED)
    11. Verify AdaptiveDifficultyEngineTests.swift exists at TimeQuest/Tests/ path
    12. Verify NO files under Features/Player/Views/ or Features/Shared/Views/ are in the files_modified list (difficulty changes are backend-only -- no View files should be touched)
    13. Grep for `"difficulty"` in all files under Features/Player/Views/ and Features/Shared/ -- should find 0 player-facing difficulty strings (DIFF-03 compliance check across entire codebase, not just modified files)
  </verify>
  <done>
    AdaptiveDifficultyEngine is a pure Foundation engine with EMA, monotonic ratchet, and minimum-sessions guard. GameSessionViewModel.completeActiveTask() implements the full difficulty flow: fetch per-task state, score with level-appropriate thresholds, update EMA (skipped during calibration), apply ratchet, stamp session. XPEngine scales per-estimation XP with difficulty multiplier. Comprehensive unit tests cover EMA convergence, ratchet behavior, bad-streak resilience, threshold lookup, and XP scaling. Build succeeds. No player-facing difficulty indicators exist.
  </done>
</task>

</tasks>

<verification>
Phase 7 Plan 02 end-to-end verification:
1. Build succeeds: `xcodebuild -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build`
2. DIFF-01: GameSessionViewModel fetches per-task difficulty state and passes level-appropriate AccuracyThresholds to TimeEstimationScorer -- grep for `AdaptiveDifficultyEngine.thresholds` in GameSessionViewModel.swift
3. DIFF-02: AdaptiveDifficultyEngine.difficultyLevel() uses max(currentLevel, computed) -- grep confirms; unit test `testMonotonicRatchetNeverDecreases` and `testBadStreakDoesNotDecreaseDifficulty` verify
4. DIFF-03: Grep all files under Features/ for player-facing "difficulty" strings -- zero results
5. DIFF-04: XPEngine.xpForEstimation applies DifficultyConfiguration multiplier (1.0x to 2.0x) -- unit test `testLevel5DoubleXP` verifies
6. DIFF-05: GameSession stores difficultyLevel and xpMultiplier per session; accuracyPercent calculation is unchanged in TimeEstimationScorer (only rating changes)
7. Calibration interaction: `if !isCalibration` guard wraps entire difficulty update block -- verified by grep
8. AdaptiveDifficultyEngine.swift in generate-xcodeproj.js sourceFiles and groups
</verification>

<success_criteria>
- AdaptiveDifficultyEngine is Foundation-only with monotonic ratchet and minimum-sessions guard
- TimeEstimationScorer.score() accepts AccuracyThresholds (default = Level 1 bands)
- accuracyPercent calculation is UNCHANGED (difficulty-independent)
- XPEngine scales per-estimation XP by difficulty multiplier, completion bonus NOT scaled
- GameSessionViewModel.completeActiveTask() implements: fetch state -> score with thresholds -> update EMA (skip if calibrating) -> ratchet level -> stamp session
- GameSessionViewModel.advanceToNextTask() passes difficultyLevel to XPEngine and stamps session
- Session records difficultyLevel and xpMultiplier for fair historical comparison
- AdaptiveDifficultyEngineTests.swift covers EMA, monotonic ratchet, minimum sessions, thresholds, XP multiplier, full flow simulation
- generate-xcodeproj.js registers AdaptiveDifficultyEngine.swift
- `xcodebuild build` succeeds
- Zero player-facing difficulty references in any View file
</success_criteria>

## Estimated Scope

- **New files:** 2 (AdaptiveDifficultyEngine.swift ~40 LOC, AdaptiveDifficultyEngineTests.swift ~150 LOC)
- **Modified files:** 4 (TimeEstimationScorer.swift, XPEngine.swift, GameSessionViewModel.swift, generate-xcodeproj.js)
- **Estimated LOC added/changed:** ~280

<output>
After completion, create `.planning/phases/07-schema-evolution-adaptive-difficulty/07-02-SUMMARY.md`
</output>

---
phase: 06-weekly-reflection-summaries
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - TimeQuest/Models/WeeklyReflection.swift
  - TimeQuest/Domain/WeeklyReflectionEngine.swift
  - TimeQuest/Features/Player/ViewModels/WeeklyReflectionViewModel.swift
  - generate-xcodeproj.js
autonomous: true

must_haves:
  truths:
    - "WeeklyReflectionEngine computes a WeeklyReflection from past 7 days of estimation snapshots"
    - "Summary includes quests completed, average accuracy, accuracy change vs prior week"
    - "Summary includes best estimate of the week (highest single accuracy) and most improved task (biggest accuracy gain vs prior week)"
    - "Streak context is framed positively as 'N of 7 days' -- never shows missed days"
    - "Summary includes one pattern highlight from InsightEngine, filtered to tasks played that week"
    - "Most improved task only compares tasks with data in BOTH this week and prior week (minimum 2 estimations per week per task)"
    - "Empty weeks (zero quests) produce a reflection where isMeaningful returns false"
    - "WeeklyReflectionViewModel computes reflection lazily on app open, not via background scheduler"
    - "UserDefaults tracks 'last shown week' and 'dismissed week' state -- no schema change needed"
    - "ViewModel computes up to 4 weeks of reflection history for stats view"
  artifacts:
    - path: "TimeQuest/Models/WeeklyReflection.swift"
      provides: "Value type containing all weekly summary metrics"
      contains: "struct WeeklyReflection"
    - path: "TimeQuest/Domain/WeeklyReflectionEngine.swift"
      provides: "Pure domain engine computing weekly summaries from EstimationSnapshot arrays"
      contains: "struct WeeklyReflectionEngine"
    - path: "TimeQuest/Features/Player/ViewModels/WeeklyReflectionViewModel.swift"
      provides: "ViewModel driving reflection card display and history loading"
      contains: "class WeeklyReflectionViewModel"
  key_links:
    - from: "TimeQuest/Domain/WeeklyReflectionEngine.swift"
      to: "TimeQuest/Models/EstimationSnapshot.swift"
      via: "Consumes [EstimationSnapshot] as input, same pattern as InsightEngine"
      pattern: "EstimationSnapshot"
    - from: "TimeQuest/Domain/WeeklyReflectionEngine.swift"
      to: "TimeQuest/Domain/InsightEngine.swift"
      via: "Calls InsightEngine.generateInsights() to pick one pattern highlight"
      pattern: "InsightEngine\\.generateInsights"
    - from: "TimeQuest/Features/Player/ViewModels/WeeklyReflectionViewModel.swift"
      to: "TimeQuest/Domain/WeeklyReflectionEngine.swift"
      via: "Calls computeReflection() and previousWeekBounds() to generate summaries"
      pattern: "WeeklyReflectionEngine\\.computeReflection"
    - from: "TimeQuest/Features/Player/ViewModels/WeeklyReflectionViewModel.swift"
      to: "UserDefaults"
      via: "ReflectionDefaults tracks last shown week and dismissed state"
      pattern: "ReflectionDefaults"
---

<objective>
Create the WeeklyReflection value type, WeeklyReflectionEngine pure domain engine, and WeeklyReflectionViewModel -- the complete data/logic layer for weekly reflection summaries.

Purpose: This plan builds the computational foundation that produces weekly summaries from existing session data. The engine follows the exact InsightEngine pattern (pure Foundation struct, static functions, EstimationSnapshot input). The ViewModel handles SwiftData fetching, UserDefaults week tracking, and lazy computation on app open.

Output: WeeklyReflection.swift, WeeklyReflectionEngine.swift, WeeklyReflectionViewModel.swift, updated generate-xcodeproj.js.
</objective>

<execution_context>
@/Users/davezabihaylo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davezabihaylo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-weekly-reflection-summaries/06-RESEARCH.md

# Key source files to read before implementing
@TimeQuest/Domain/InsightEngine.swift
@TimeQuest/Models/EstimationSnapshot.swift
@TimeQuest/Features/Player/ViewModels/ProgressionViewModel.swift
@TimeQuest/Repositories/SessionRepository.swift
@TimeQuest/Features/Shared/Components/TimeFormatting.swift
@TimeQuest/App/AppDependencies.swift
@generate-xcodeproj.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: WeeklyReflection value type and WeeklyReflectionEngine pure domain engine</name>
  <files>
    TimeQuest/Models/WeeklyReflection.swift
    TimeQuest/Domain/WeeklyReflectionEngine.swift
  </files>
  <action>
**WeeklyReflection.swift** (new file in Models/):

Create a plain Foundation-only value type containing all computed weekly metrics. This is the single output of WeeklyReflectionEngine. Must conform to Sendable for Swift 6 strict concurrency.

```swift
import Foundation

struct WeeklyReflection: Sendable {
    let weekStartDate: Date
    let weekEndDate: Date

    // REQ-034: Core metrics
    let questsCompleted: Int
    let averageAccuracy: Double          // 0-100
    let accuracyChangeVsPriorWeek: Double?  // Signed delta; nil if no prior week data

    // REQ-035: Highlights
    let bestEstimateTaskName: String?
    let bestEstimateAccuracy: Double?
    let mostImprovedTaskName: String?
    let mostImprovedDelta: Double?       // Positive = improved

    // REQ-036: Streak context (positive framing)
    let daysPlayedThisWeek: Int          // 0-7
    let totalDaysInWeek: Int             // Always 7

    // REQ-037: Insight highlight
    let patternHighlight: String?

    // REQ-042: Metadata
    let hasGaps: Bool
    let totalEstimations: Int

    var streakContextString: String {
        "\(daysPlayedThisWeek) of \(totalDaysInWeek) days"
    }

    var isMeaningful: Bool {
        questsCompleted > 0
    }

    var formattedAccuracyChange: String? {
        guard let delta = accuracyChangeVsPriorWeek else { return nil }
        let sign = delta >= 0 ? "+" : ""
        return "\(sign)\(Int(delta))%"
    }
}
```

**WeeklyReflectionEngine.swift** (new file in Domain/):

Create a pure Foundation struct with static functions. ZERO SwiftData or SwiftUI imports -- follows the exact InsightEngine pattern. Consumes `[EstimationSnapshot]` and date ranges, produces `WeeklyReflection`.

Key functions to implement:

1. `computeReflection(snapshots:weekStart:weekEnd:priorWeekSnapshots:completedQuestCount:) -> WeeklyReflection`
   - Filter snapshots to non-calibration entries within [weekStart, weekEnd)
   - Compute averageAccuracy from filtered snapshots' accuracyPercent values
   - Compute accuracyChangeVsPriorWeek: if priorWeekSnapshots is non-nil and non-empty, compute their average accuracy and take the delta. If nil or empty, return nil for this field.
   - Find bestEstimate: the snapshot with the highest single accuracyPercent this week
   - Find mostImproved: call findMostImprovedTask() (see below)
   - Count daysPlayed: unique calendar days from snapshot recordedAt dates using Calendar.current.startOfDay
   - Get patternHighlight: call pickPatternHighlight() (see below)
   - questsCompleted: use the `completedQuestCount` parameter passed in from the ViewModel (NOT snapshot counting, since each snapshot is a task estimation, not a session)
   - hasGaps = daysPlayed < 7
   - totalEstimations = count of filtered week snapshots

2. `previousWeekBounds(from:) -> (start: Date, end: Date)`
   - Use Calendar.current.dateInterval(of: .weekOfYear, for: date) to get current week start
   - Previous week start = calendar.date(byAdding: .day, value: -7, to: currentWeekStart)
   - Return (prevWeekStart, currentWeekStart)
   - NEVER use TimeInterval arithmetic (86400 * 7) -- Calendar handles DST correctly

3. `weekBounds(weeksBack:from:) -> (start: Date, end: Date)`
   - Use Calendar.current.dateInterval(of: .weekOfYear, for: date) for current week start
   - Target start = calendar.date(byAdding: .day, value: -7 * weeksBack, to: currentWeekStart)
   - Target end = calendar.date(byAdding: .day, value: 7, to: targetStart)
   - Return (targetStart, targetEnd)

4. `findMostImprovedTask(thisWeek:priorWeek:) -> ImprovementResult?`
   - Group both arrays by taskDisplayName (filtering out calibration)
   - For each task present in BOTH weeks with at least 2 estimations per week per task: compute average accuracy for each week, calculate delta
   - Return the task with the largest positive delta
   - If no task meets the threshold (present in both weeks with 2+ estimations each), return nil
   - Define a nested `ImprovementResult` struct: `let taskName: String, let delta: Double`

5. `pickPatternHighlight(from:weekTaskNames:) -> String?`
   - Call InsightEngine.generateInsights(snapshots: allSnapshots)
   - Filter returned TaskInsights to only tasks whose taskDisplayName is in weekTaskNames (tasks played this week)
   - Priority order: (1) improving trend -> "Your [task] estimates are getting closer over time", (2) notable bias -> "You tend to [overestimate/underestimate] [task]", (3) very consistent -> "You read [task] the same way each time"
   - If no interesting insight exists for this week's tasks, return nil

All date arithmetic MUST use Calendar methods (dateInterval, date(byAdding:), startOfDay), never TimeInterval multiplication.
  </action>
  <verify>
- grep "struct WeeklyReflection" in WeeklyReflection.swift to confirm value type exists
- grep "Sendable" in WeeklyReflection.swift to confirm Swift 6 concurrency compliance
- grep "struct WeeklyReflectionEngine" in WeeklyReflectionEngine.swift to confirm engine exists
- grep "import Foundation" in WeeklyReflectionEngine.swift to confirm it only imports Foundation (NOT SwiftData or SwiftUI)
- grep "InsightEngine.generateInsights" in WeeklyReflectionEngine.swift to confirm pattern highlight integration
- grep "computeReflection" in WeeklyReflectionEngine.swift to confirm main function exists
- grep "previousWeekBounds\|weekBounds" in WeeklyReflectionEngine.swift to confirm date helpers exist
- grep "findMostImprovedTask" in WeeklyReflectionEngine.swift to confirm improvement detection exists
- grep "Calendar.current" in WeeklyReflectionEngine.swift to confirm proper date arithmetic (no 86400)
- grep "isMeaningful" in WeeklyReflection.swift to confirm empty-week guard exists
- grep "streakContextString" in WeeklyReflection.swift to confirm positive framing computed property
  </verify>
  <done>
WeeklyReflection value type has all fields for REQ-034 through REQ-037 plus REQ-042 metadata. WeeklyReflectionEngine is a pure Foundation struct with static functions that: computes weekly summaries from EstimationSnapshot arrays, uses Calendar for DST-safe date arithmetic, finds most improved task (with 2-estimation-per-week minimum and both-weeks-present requirement), and picks one pattern highlight from InsightEngine filtered to this week's tasks. Streak context is always positive framing via streakContextString computed property.
  </done>
</task>

<task type="auto">
  <name>Task 2: WeeklyReflectionViewModel and build system registration</name>
  <files>
    TimeQuest/Features/Player/ViewModels/WeeklyReflectionViewModel.swift
    generate-xcodeproj.js
  </files>
  <action>
**WeeklyReflectionViewModel.swift** (new file):

Create an @MainActor @Observable ViewModel following the exact ProgressionViewModel pattern. This ViewModel bridges SwiftData to the pure domain engine and manages UserDefaults week-tracking state.

```swift
import Foundation
import SwiftData

// MARK: - UserDefaults Week Tracking

enum ReflectionDefaults {
    private static let lastShownWeekKey = "reflection_lastShownWeek"
    private static let dismissedWeekKey = "reflection_dismissedWeek"

    static func weekIdentifier(for date: Date) -> String {
        let calendar = Calendar(identifier: .iso8601)
        let year = calendar.component(.yearForWeekOfYear, from: date)
        let week = calendar.component(.weekOfYear, from: date)
        return "\(year)-W\(String(format: "%02d", week))"
    }

    static var lastShownWeek: String? {
        get { UserDefaults.standard.string(forKey: lastShownWeekKey) }
        set { UserDefaults.standard.set(newValue, forKey: lastShownWeekKey) }
    }

    static var dismissedWeek: String? {
        get { UserDefaults.standard.string(forKey: dismissedWeekKey) }
        set { UserDefaults.standard.set(newValue, forKey: dismissedWeekKey) }
    }

    static func shouldShowReflection(now: Date = .now) -> Bool {
        let (prevWeekStart, _) = WeeklyReflectionEngine.previousWeekBounds(from: now)
        let previousWeekID = weekIdentifier(for: prevWeekStart)
        if lastShownWeek != previousWeekID { return true }
        return dismissedWeek != previousWeekID
    }
}
```

ViewModel class:

```swift
@MainActor
@Observable
final class WeeklyReflectionViewModel {
    var currentReflection: WeeklyReflection?
    var shouldShowCard: Bool = false
    var reflectionHistory: [WeeklyReflection] = []

    private let modelContext: ModelContext

    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    func refresh() { ... }
    func dismissCurrentReflection() { ... }
    private func loadHistory() { ... }
    private func fetchSnapshots(from start: Date, to end: Date) -> [EstimationSnapshot] { ... }
    private func countCompletedSessions(from start: Date, to end: Date) -> Int { ... }
}
```

Key implementation details for each method:

**refresh()** (REQ-038: lazy on app open):
- Check ReflectionDefaults.shouldShowReflection(). If false, set shouldShowCard = false, call loadHistory(), and return.
- If true, compute the reflection for the previous completed week:
  - Get week bounds via WeeklyReflectionEngine.previousWeekBounds(from: now)
  - Get prior week bounds via WeeklyReflectionEngine.weekBounds(weeksBack: 2, from: now)
  - Fetch all snapshots covering both weeks via fetchSnapshots(from: priorStart, to: weekEnd)
  - Count completed sessions via countCompletedSessions(from: weekStart, to: weekEnd) -- this queries GameSession directly for accurate quest count (not snapshot counting)
  - Call WeeklyReflectionEngine.computeReflection() with the snapshots, dates, and quest count
  - If reflection.isMeaningful, set currentReflection, shouldShowCard = true, and update ReflectionDefaults.lastShownWeek
  - Call loadHistory()

**dismissCurrentReflection()** (REQ-039):
- Set shouldShowCard = false
- If currentReflection exists, set ReflectionDefaults.dismissedWeek to the week identifier

**loadHistory()** (REQ-040, REQ-042):
- Loop weeksBack from 1 to 4
- For each week, get bounds, fetch snapshots, count sessions, compute reflection
- If reflection.isMeaningful, append to history
- Set reflectionHistory

**fetchSnapshots(from:to:):**
- Create FetchDescriptor<TaskEstimation> with #Predicate filtering recordedAt >= start && recordedAt < end, sorted by recordedAt
- Fetch and map to EstimationSnapshot using the existing init(from:) bridge

**countCompletedSessions(from:to:):**
- Create FetchDescriptor<GameSession> with #Predicate filtering completedAt != nil
- Fetch all sessions, then filter in-memory to completedAt >= start && completedAt < end && !isCalibration
- Return count
- NOTE: We can't use a complex #Predicate with optional Date comparisons in SwiftData (completedAt is Date?), so fetch all completed sessions and filter in-memory. The dataset is small.

**generate-xcodeproj.js** updates:

Add 3 new source files to the sourceFiles array:
```javascript
{ name: 'WeeklyReflection.swift', path: 'Models/WeeklyReflection.swift' },
{ name: 'WeeklyReflectionEngine.swift', path: 'Domain/WeeklyReflectionEngine.swift' },
{ name: 'WeeklyReflectionViewModel.swift', path: 'Features/Player/ViewModels/WeeklyReflectionViewModel.swift' },
```

Add to the appropriate groups:
- 'WeeklyReflection.swift' to the Models group files array
- 'WeeklyReflectionEngine.swift' to the Domain group files array
- 'WeeklyReflectionViewModel.swift' to the PlayerViewModels group files array

Do NOT add UI files yet -- Plan 06-02 handles WeeklyReflectionCardView registration.

Run `node generate-xcodeproj.js` to regenerate the project file.

Verify build: `cd TimeQuest && xcodebuild build -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' -quiet 2>&1 | tail -5`
  </action>
  <verify>
- grep "class WeeklyReflectionViewModel" in WeeklyReflectionViewModel.swift to confirm ViewModel exists
- grep "@MainActor" in WeeklyReflectionViewModel.swift to confirm proper actor isolation
- grep "@Observable" in WeeklyReflectionViewModel.swift to confirm observation pattern
- grep "ReflectionDefaults" in WeeklyReflectionViewModel.swift to confirm UserDefaults integration
- grep "shouldShowReflection" in WeeklyReflectionViewModel.swift to confirm lazy check exists
- grep "countCompletedSessions" in WeeklyReflectionViewModel.swift to confirm quest counting uses GameSession (not snapshots)
- grep "WeeklyReflection.swift\|WeeklyReflectionEngine.swift\|WeeklyReflectionViewModel.swift" in generate-xcodeproj.js to confirm all 3 files registered
- Build succeeds: xcodebuild build
  </verify>
  <done>
WeeklyReflectionViewModel lazily checks whether a new weekly reflection should be shown on app open (REQ-038), computes reflection via WeeklyReflectionEngine, tracks shown/dismissed state via UserDefaults (no schema change), counts quests via GameSession query (not snapshot counting), and loads 4 weeks of history for stats view (REQ-040, REQ-042). ReflectionDefaults uses ISO 8601 week identifiers for consistent storage. All 3 new files registered in generate-xcodeproj.js. Build compiles.
  </done>
</task>

</tasks>

<verification>
1. WeeklyReflection has all required fields (REQ-034: quests/accuracy/delta, REQ-035: bestEstimate/mostImproved, REQ-036: streakContext, REQ-037: patternHighlight) -- inspect struct fields
2. WeeklyReflectionEngine imports only Foundation -- grep "^import" in WeeklyReflectionEngine.swift
3. Engine uses Calendar for date arithmetic -- grep "Calendar" and confirm no "86400" in WeeklyReflectionEngine.swift
4. Engine calls InsightEngine.generateInsights for pattern highlights -- grep "InsightEngine" in WeeklyReflectionEngine.swift
5. Most improved task requires both-weeks data with 2+ estimations -- inspect findMostImprovedTask logic
6. ViewModel is @MainActor @Observable -- grep annotations in WeeklyReflectionViewModel.swift
7. ViewModel uses UserDefaults, not schema changes -- grep "UserDefaults" and confirm no schema references
8. Quest count uses GameSession, not snapshot counting -- grep "countCompletedSessions" in ViewModel
9. All 3 files registered in generate-xcodeproj.js
10. Build compiles without errors
</verification>

<success_criteria>
- WeeklyReflection value type carries all metrics for REQ-033 through REQ-037 plus REQ-042
- WeeklyReflectionEngine is pure Foundation (no SwiftData/SwiftUI), consumes EstimationSnapshot arrays
- Streak context is always positively framed ("N of 7 days") via computed property
- Pattern highlight is sourced from InsightEngine, filtered to this week's tasks
- Most improved task comparison requires data in both weeks (no "infinitely improved" new tasks)
- Empty weeks produce non-meaningful reflections that are excluded from display
- ViewModel computes lazily on app open (REQ-038), not via background scheduler
- UserDefaults tracks week state without schema changes
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-weekly-reflection-summaries/06-01-SUMMARY.md`
</output>

---
phase: 09-spotify-integration
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - TimeQuest/Services/SpotifyAuthManager.swift
  - TimeQuest/Services/KeychainHelper.swift
  - TimeQuest/Services/SpotifyAPIClient.swift
  - TimeQuest/App/AppDependencies.swift
  - generate-xcodeproj.js
autonomous: true
user_setup:
  - service: spotify
    why: "Spotify Web API OAuth for playlist access and currently-playing polling"
    env_vars: []
    account_setup:
      - task: "Create Spotify Developer account and app"
        location: "https://developer.spotify.com/dashboard"
      - task: "Note the Client ID from the app settings"
        location: "Spotify Dashboard -> App -> Settings -> Client ID"
      - task: "Add redirect URI: timequest://spotify-callback"
        location: "Spotify Dashboard -> App -> Settings -> Redirect URIs"
      - task: "Add test user email addresses to the app allowlist (Dev Mode: max 5 users)"
        location: "Spotify Dashboard -> App -> Settings -> User Management"

must_haves:
  truths:
    - "SpotifyAuthManager can construct a PKCE authorization URL with correct scopes and challenge"
    - "SpotifyAuthManager can exchange an authorization code for access and refresh tokens"
    - "SpotifyAuthManager can refresh an expired access token without user interaction"
    - "Tokens are stored in Keychain (not UserDefaults) and survive app restart"
    - "SpotifyAPIClient returns decoded SpotifyPlaylist array from /me/playlists"
    - "SpotifyAPIClient returns NowPlayingInfo or nil from /me/player/currently-playing"
    - "SpotifyAPIClient automatically retries on 401 (token refresh) and 429 (rate limit)"
    - "Concurrent token refresh requests share a single in-flight refresh task (no race condition)"
  artifacts:
    - path: "TimeQuest/Services/SpotifyAuthManager.swift"
      provides: "OAuth PKCE flow with ASWebAuthenticationSession, token lifecycle"
      contains: "ASWebAuthenticationSession"
    - path: "TimeQuest/Services/KeychainHelper.swift"
      provides: "Keychain CRUD for token storage"
      contains: "SecItemAdd"
    - path: "TimeQuest/Services/SpotifyAPIClient.swift"
      provides: "Authenticated HTTP client for Spotify Web API endpoints"
      contains: "authenticatedRequest"
    - path: "TimeQuest/App/AppDependencies.swift"
      provides: "SpotifyAuthManager registered as dependency"
      contains: "spotifyAuthManager"
  key_links:
    - from: "TimeQuest/Services/SpotifyAPIClient.swift"
      to: "TimeQuest/Services/SpotifyAuthManager.swift"
      via: "authManager.validAccessToken() for Bearer header"
      pattern: "authManager\\.validAccessToken"
    - from: "TimeQuest/Services/SpotifyAuthManager.swift"
      to: "TimeQuest/Services/KeychainHelper.swift"
      via: "KeychainHelper.save/load for token persistence"
      pattern: "KeychainHelper\\.(save|load)"
    - from: "TimeQuest/App/AppDependencies.swift"
      to: "TimeQuest/Services/SpotifyAuthManager.swift"
      via: "Property initialization"
      pattern: "SpotifyAuthManager\\(\\)"
---

<objective>
Build the Spotify OAuth and API service layer: PKCE authorization flow via ASWebAuthenticationSession, secure Keychain token storage, and an authenticated HTTP client for Spotify Web API endpoints.

Purpose: This is the critical infrastructure that all Spotify features depend on. Without working auth and API access, no playlist browsing, no playback launch, no "Now Playing" polling.
Output: SpotifyAuthManager.swift, KeychainHelper.swift, SpotifyAPIClient.swift, updated AppDependencies.swift.
</objective>

<execution_context>
@/Users/davezabihaylo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davezabihaylo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-spotify-integration/09-RESEARCH.md
@.planning/phases/09-spotify-integration/09-01-SUMMARY.md

@TimeQuest/Services/CalendarService.swift
@TimeQuest/App/AppDependencies.swift
@TimeQuest/Models/SpotifyModels.swift
@generate-xcodeproj.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SpotifyAuthManager with PKCE OAuth flow and KeychainHelper for token storage</name>
  <files>
    TimeQuest/Services/SpotifyAuthManager.swift
    TimeQuest/Services/KeychainHelper.swift
  </files>
  <action>
    Create KeychainHelper.swift -- a simple struct with static methods for Keychain CRUD:
    - `private static let service = "com.timequest.spotify"`
    - `static func save(_ data: Data, forKey key: String) throws` -- deletes existing item first, then adds (SecItemDelete + SecItemAdd). Throws SpotifyError.keychainError(status) on failure.
    - `static func load(forKey key: String) -> Data?` -- SecItemCopyMatching with kSecMatchLimitOne
    - `static func delete(forKey key: String)` -- SecItemDelete (ignore result)
    - Import Security framework only

    Create SpotifyAuthManager.swift as `@MainActor @Observable final class SpotifyAuthManager: NSObject`:
    - Follow CalendarService and NotificationManager patterns exactly
    - Import AuthenticationServices, CryptoKit, Foundation

    Published/observable state:
    - `var isConnected: Bool = false`
    - `var userDisplayName: String?`
    - `private(set) var isAuthenticating: Bool = false`

    Constants:
    - `private let clientID = "YOUR_SPOTIFY_CLIENT_ID"` (placeholder -- user fills in from Spotify Dashboard)
    - `private let redirectURI = "timequest://spotify-callback"` (custom URL scheme)
    - `private let tokenEndpoint = "https://accounts.spotify.com/api/token"`
    - `private let authorizeEndpoint = "https://accounts.spotify.com/authorize"`

    Required scopes (as computed property returning joined string):
    - `playlist-read-private`
    - `playlist-read-collaborative`
    - `user-read-currently-playing`
    - `user-read-playback-state`
    (NO Premium-requiring scopes like user-modify-playback-state or streaming)

    PKCE helpers (private):
    - `generateCodeVerifier() -> String` -- 64 random bytes via SecRandomCopyBytes, base64url-encoded, truncated to 128 chars
    - `generateCodeChallenge(from verifier: String) -> String` -- SHA256 hash via CryptoKit, base64url-encoded

    Main auth flow:
    - `func authorize() async throws` -- generates verifier + challenge, constructs auth URL with all query params (client_id, response_type=code, redirect_uri, code_challenge_method=S256, code_challenge, scope), presents ASWebAuthenticationSession, extracts code from callback URL, exchanges for tokens, saves to Keychain, fetches user profile to set displayName, sets isConnected = true.
    - Set `prefersEphemeralWebBrowserSession = false` so existing Safari Spotify login is reused (better UX for family app -- see research pitfall #7).
    - Conform to ASWebPresentationContextProviding via extension. Use the `nonisolated + MainActor.assumeIsolated` pattern (same as CalendarChooserView Coordinator in Phase 8 -- see 08-03 decisions).

    Token exchange:
    - `func exchangeCodeForTokens(code: String, verifier: String) async throws -> SpotifyTokens` -- POST to token endpoint with form-urlencoded body (grant_type=authorization_code, code, redirect_uri, client_id, code_verifier). Decode response as SpotifyTokens.
    - Create `struct SpotifyTokens: Codable` with accessToken, tokenType, expiresIn, refreshToken, scope (all with CodingKeys for snake_case).

    Token storage (Keychain):
    - `func saveTokens(_ tokens: SpotifyTokens) throws` -- encode access token, refresh token, and expiration date (Date.now + expiresIn) to Keychain via KeychainHelper
    - Store three separate Keychain entries: "access_token", "refresh_token", "token_expiry"
    - `func loadTokens() -> (accessToken: String, refreshToken: String, expiryDate: Date)?` -- loads all three, returns nil if any missing

    Token refresh with race condition protection:
    - `private var refreshTask: Task<String, Error>?` -- single in-flight refresh task
    - `func validAccessToken() async throws -> String` -- checks expiry (with 60s buffer). If valid, returns stored token. If expired, calls refreshToken(). If refreshTask already exists, awaits it instead of starting a new one.
    - `func refreshToken() async throws` -- POST to token endpoint with grant_type=refresh_token, refresh_token, client_id. Saves new tokens. NOTE: Spotify PKCE refresh may return a new refresh_token -- always save it if present.

    Disconnect:
    - `func disconnect()` -- deletes all three Keychain entries, sets isConnected = false, clears userDisplayName

    Init / restore:
    - In init(), check if tokens exist in Keychain. If so, set isConnected = true. Optionally validate by calling /me endpoint (but do NOT block init on network call -- do it lazily).

    Add a `func fetchUserProfile() async throws -> SpotifyUserProfile` that calls GET /me to verify connection and get display name. Use this after token exchange to populate userDisplayName.

    IMPORTANT security notes from research:
    - NEVER store tokens in UserDefaults (Keychain only)
    - NEVER log access tokens or refresh tokens
    - Client ID is public (PKCE has no client secret) -- safe to embed in source
  </action>
  <verify>Run `node generate-xcodeproj.js && xcodebuild -project TimeQuest/TimeQuest.xcodeproj -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -5` -- build succeeds.</verify>
  <done>SpotifyAuthManager presents PKCE OAuth flow via ASWebAuthenticationSession, stores tokens in Keychain, supports refresh with race condition protection, and exposes isConnected observable state. KeychainHelper provides save/load/delete for Keychain entries.</done>
</task>

<task type="auto">
  <name>Task 2: Create SpotifyAPIClient, wire into AppDependencies, register files in build system</name>
  <files>
    TimeQuest/Services/SpotifyAPIClient.swift
    TimeQuest/App/AppDependencies.swift
    generate-xcodeproj.js
  </files>
  <action>
    Create SpotifyAPIClient.swift as `@MainActor final class SpotifyAPIClient`:
    - `private let authManager: SpotifyAuthManager`
    - `private let baseURL = "https://api.spotify.com/v1"`
    - `init(authManager: SpotifyAuthManager)`

    Core authenticated request method:
    - `private func authenticatedRequest(path: String, queryItems: [URLQueryItem] = []) async throws -> Data`
    - Gets token via `authManager.validAccessToken()`
    - Constructs URL with base + path + queryItems
    - Sets Authorization: Bearer header
    - Handles response codes:
      - 200: return data
      - 204: return empty Data (nothing playing)
      - 401: refresh token via authManager, retry ONCE (prevent infinite loop)
      - 429: parse Retry-After header (default 5s), sleep, retry ONCE
      - Other: throw SpotifyError.httpError(statusCode:)

    Public API methods:
    - `func getUserProfile() async throws -> SpotifyUserProfile` -- GET /me, decode as SpotifyUserProfile
    - `func getUserPlaylists(limit: Int = 50, offset: Int = 0) async throws -> PagingObject<SpotifyPlaylist>` -- GET /me/playlists with limit and offset query params
    - `func getPlaylistTracks(playlistID: String) async throws -> [SpotifyTrack]` -- GET /playlists/{id}/tracks with pagination (loop while next != nil). Use fields param: "items(track(name,duration_ms,artists(name),album(images))),next,total" to minimize response size. CompactMap track (can be nil for local tracks).
    - `func getCurrentlyPlaying() async throws -> NowPlayingInfo?` -- GET /me/player/currently-playing. Return nil if data is empty (204) or isPlaying is false. Convert via toNowPlayingInfo().

    Update AppDependencies.swift:
    - Add `let spotifyAuthManager: SpotifyAuthManager` property
    - Add `let spotifyAPIClient: SpotifyAPIClient` property
    - In init: create SpotifyAuthManager(), then SpotifyAPIClient(authManager: spotifyAuthManager)
    - Follow exact pattern of existing services (calendarService, soundManager, etc.)

    Register in generate-xcodeproj.js:
    - Add to sourceFiles array: SpotifyAuthManager.swift (Services/), KeychainHelper.swift (Services/), SpotifyAPIClient.swift (Services/)
    - Add to Services group files array: 'SpotifyAuthManager.swift', 'KeychainHelper.swift', 'SpotifyAPIClient.swift'
  </action>
  <verify>Run `node generate-xcodeproj.js && xcodebuild -project TimeQuest/TimeQuest.xcodeproj -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -5` -- build succeeds with all service files compiled and AppDependencies updated.</verify>
  <done>SpotifyAPIClient provides typed methods for all 4 Spotify endpoints (profile, playlists, tracks, currently-playing). AppDependencies exposes spotifyAuthManager and spotifyAPIClient. All 3 service files registered in build system. Clean build.</done>
</task>

</tasks>

<verification>
- SpotifyAuthManager.authorize() constructs valid PKCE auth URL with all required params
- SpotifyAuthManager.validAccessToken() handles refresh transparently
- KeychainHelper.save/load/delete work for string data
- SpotifyAPIClient.getUserPlaylists returns decoded PagingObject of SpotifyPlaylist
- SpotifyAPIClient.getCurrentlyPlaying returns nil for 204 responses
- AppDependencies.spotifyAuthManager and .spotifyAPIClient are accessible
- Project builds clean with xcodebuild
</verification>

<success_criteria>
- Complete PKCE OAuth lifecycle: authorize -> exchange -> save -> refresh -> disconnect
- Tokens never touch UserDefaults (Keychain only)
- Race-safe token refresh (single in-flight task)
- API client handles 401 refresh and 429 rate limiting automatically
- All service files registered and building
</success_criteria>

<output>
After completion, create `.planning/phases/09-spotify-integration/09-02-SUMMARY.md`
</output>

---
phase: 08-calendar-intelligence
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - TimeQuest/Services/CalendarService.swift
  - TimeQuest/App/AppDependencies.swift
  - TimeQuest/Features/Parent/Views/CalendarSettingsView.swift
  - TimeQuest/Features/Parent/Views/CalendarChooserView.swift
  - TimeQuest/Features/Parent/Views/ParentDashboardView.swift
  - TimeQuest/Features/Parent/Views/RoutineEditorView.swift
  - TimeQuest/Features/Player/Views/PlayerHomeView.swift
  - generate-xcodeproj.js
autonomous: true

must_haves:
  truths:
    - "On a school day, the player sees school morning routines surfaced automatically"
    - "On a holiday or free day, school-specific routines (calendarMode=schoolDayOnly) are hidden"
    - "A player who denies calendar permission sees the app identically to v2.0 -- no broken screens, no nagging"
    - "Calendar data is never stored in SwiftData -- CalendarService reads fresh from EventKit each time"
    - "Parent can enable calendar access and select school calendars from parent settings"
    - "Parent can set a routine's calendar mode to schoolDayOnly, freeDayOnly, or always in the routine editor"
    - "A passive context chip above the quest list shows 'School day' or 'Free day' when calendar is active"
  artifacts:
    - path: "TimeQuest/Services/CalendarService.swift"
      provides: "EventKit wrapper with permission, event fetching, calendar access"
      contains: "CalendarService"
    - path: "TimeQuest/Features/Parent/Views/CalendarSettingsView.swift"
      provides: "Parent UI for calendar permission and calendar selection"
      contains: "CalendarSettingsView"
    - path: "TimeQuest/Features/Parent/Views/CalendarChooserView.swift"
      provides: "UIViewControllerRepresentable wrapper for EKCalendarChooser"
      contains: "EKCalendarChooser"
    - path: "TimeQuest/Features/Player/Views/PlayerHomeView.swift"
      provides: "Calendar-filtered quest list with context chip"
      contains: "CalendarContextEngine"
  key_links:
    - from: "TimeQuest/Features/Player/Views/PlayerHomeView.swift"
      to: "TimeQuest/Services/CalendarService.swift"
      via: "dependencies.calendarService for event fetching"
      pattern: "calendarService"
    - from: "TimeQuest/Features/Player/Views/PlayerHomeView.swift"
      to: "TimeQuest/Domain/CalendarContextEngine.swift"
      via: "CalendarContextEngine().determineContext() for day classification"
      pattern: "determineContext"
    - from: "TimeQuest/Features/Player/Views/PlayerHomeView.swift"
      to: "TimeQuest/Domain/CalendarContextEngine.swift"
      via: "CalendarContextEngine().shouldShow() for routine filtering"
      pattern: "shouldShow"
    - from: "TimeQuest/App/AppDependencies.swift"
      to: "TimeQuest/Services/CalendarService.swift"
      via: "CalendarService registered as dependency"
      pattern: "calendarService"
    - from: "TimeQuest/Features/Parent/Views/CalendarSettingsView.swift"
      to: "TimeQuest/Services/CalendarService.swift"
      via: "Uses CalendarService for permission request and access check"
      pattern: "calendarService"
    - from: "generate-xcodeproj.js"
      to: "Info.plist"
      via: "INFOPLIST_KEY_NSCalendarsFullAccessUsageDescription build setting"
      pattern: "NSCalendarsFullAccessUsageDescription"
---

<objective>
Build CalendarService (EventKit wrapper), wire calendar filtering into PlayerHomeView, add parent UI for calendar configuration, and add calendar mode to routine editor.

Purpose: Connects the pure CalendarContextEngine from Plan 01 to real EventKit data and player-facing UI. After this plan, the app actually filters routines based on the device calendar and parents can configure which routines are calendar-sensitive.

Output: Working end-to-end calendar intelligence -- CalendarService reading EventKit, PlayerHomeView filtering routines by DayContext, parent calendar settings screen, calendarMode picker in routine editor, context chip on player home.
</objective>

<execution_context>
@/Users/davezabihaylo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davezabihaylo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-calendar-intelligence/08-RESEARCH.md
@.planning/phases/08-calendar-intelligence/08-01-SUMMARY.md

Key references (read these during execution):
@TimeQuest/Services/NotificationManager.swift - Pattern for @MainActor service with permission flow
@TimeQuest/App/AppDependencies.swift - Where to register CalendarService
@TimeQuest/Features/Player/Views/PlayerHomeView.swift - Where to wire calendar filtering
@TimeQuest/Features/Parent/Views/RoutineEditorView.swift - Where to add calendarMode picker
@TimeQuest/Features/Parent/Views/ParentDashboardView.swift - Where to add calendar settings nav
@TimeQuest/Domain/CalendarContextEngine.swift - Pure engine to wire to real data (from Plan 01)
@TimeQuest/Domain/DayContext.swift - DayContext enum (from Plan 01)
@generate-xcodeproj.js - File and build setting registration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CalendarService, register in AppDependencies, add Info.plist key and build system entries</name>
  <files>
    TimeQuest/Services/CalendarService.swift
    TimeQuest/App/AppDependencies.swift
    generate-xcodeproj.js
  </files>
  <action>
    1. Create TimeQuest/Services/CalendarService.swift:
       - Use `@preconcurrency import EventKit` (same pattern as @preconcurrency import UserNotifications in NotificationManager)
       - @MainActor final class CalendarService (follows NotificationManager pattern exactly)
       - Private let eventStore = EKEventStore() (single instance, reused -- research pitfall 2)
       - Properties:
         - var authorizationStatus: EKAuthorizationStatus { EKEventStore.authorizationStatus(for: .event) }
         - var hasAccess: Bool { authorizationStatus == .fullAccess }
       - func requestAccess() async -> Bool:
         - try await eventStore.requestFullAccessToEvents() (iOS 17+ API, NOT the deprecated requestAccess(to:))
         - catch -> return false
       - func fetchTodayEvents(from calendarIdentifiers: [String]? = nil) -> [CalendarEvent]:
         - Guard hasAccess else return []
         - Compute startOfDay and endOfDay for .now
         - If calendarIdentifiers provided, resolve them via eventStore.calendar(withIdentifier:), filter out nil (handles identifier instability -- research pitfall 1)
         - Build predicate with predicateForEvents(withStart:end:calendars:)
         - Fetch events, convert each EKEvent to CalendarEvent value type (from Plan 01's CalendarContextEngine.swift) at the boundary
         - Return [CalendarEvent] -- Sendable value types cross actor boundaries safely
       - func getEventStore() -> EKEventStore { eventStore } -- needed for EKCalendarChooser
       - Static UserDefaults keys:
         - static let selectedCalendarIDsKey = "selectedCalendarIDs"
         - static let selectedCalendarNamesKey = "selectedCalendarNames" (display fallback per research pitfall 1)
       - func selectedCalendarIDs() -> [String]? { UserDefaults.standard.stringArray(forKey: Self.selectedCalendarIDsKey) }
       - func saveSelectedCalendars(ids: [String], names: [String]) { UserDefaults.standard.set(ids, forKey: Self.selectedCalendarIDsKey); UserDefaults.standard.set(names, forKey: Self.selectedCalendarNamesKey) }
       - func clearSelectedCalendars() { UserDefaults.standard.removeObject(forKey: Self.selectedCalendarIDsKey); UserDefaults.standard.removeObject(forKey: Self.selectedCalendarNamesKey) }

    2. Update TimeQuest/App/AppDependencies.swift:
       - Add `let calendarService: CalendarService` property
       - Initialize in init: self.calendarService = CalendarService()
       - Place after notificationManager (service ordering consistency)

    3. Update generate-xcodeproj.js:
       - Add to sourceFiles: { name: 'CalendarService.swift', path: 'Services/CalendarService.swift' }
       - Add to Services group files: 'CalendarService.swift'
       - Add INFOPLIST_KEY_NSCalendarsFullAccessUsageDescription to BOTH Debug and Release build settings:
         `INFOPLIST_KEY_NSCalendarsFullAccessUsageDescription = "TimeQuest uses your calendar to automatically show the right routines on school days and hide them on holidays.";`
         Add this line after the existing INFOPLIST_KEY_UIBackgroundModes line in both build config sections.

    CRITICAL: Calendar identifiers are stored in UserDefaults (device-local), NOT in SwiftData/CloudKit. Calendar IDs are device-specific and would be meaningless on another device (research finding). Also store calendar names as a display fallback for when identifiers become invalid after iCloud sign-out.

    CRITICAL: Use `@preconcurrency import EventKit` to suppress Swift 6 strict concurrency warnings on EKEventStore and EKEvent (non-Sendable Objective-C types). Convert to Sendable CalendarEvent value types immediately after fetch.
  </action>
  <verify>
    Run: cd /Users/davezabihaylo/Projects/GSD && node generate-xcodeproj.js && xcodebuild -project TimeQuest.xcodeproj/project.pbxproj -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -5
    Build must succeed. CalendarService.swift must exist. AppDependencies must have calendarService property. grep for NSCalendarsFullAccessUsageDescription in generated project file must find it.
  </verify>
  <done>
    CalendarService exists with requestAccess(), fetchTodayEvents(), calendar ID persistence in UserDefaults. Registered in AppDependencies. Info.plist key configured in build settings. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add parent CalendarSettingsView, calendarMode picker in RoutineEditor, wire PlayerHomeView filtering with context chip</name>
  <files>
    TimeQuest/Features/Parent/Views/CalendarSettingsView.swift
    TimeQuest/Features/Parent/Views/CalendarChooserView.swift
    TimeQuest/Features/Parent/Views/ParentDashboardView.swift
    TimeQuest/Features/Parent/Views/RoutineEditorView.swift
    TimeQuest/Features/Player/Views/PlayerHomeView.swift
    generate-xcodeproj.js
  </files>
  <action>
    1. Create TimeQuest/Features/Parent/Views/CalendarChooserView.swift:
       - Import SwiftUI and EventKitUI
       - UIViewControllerRepresentable wrapping EKCalendarChooser
       - Init takes: @Binding var selectedCalendarIDs: [String], eventStore: EKEventStore
       - makeUIViewController: create EKCalendarChooser(selectionStyle: .multiple, displayStyle: .allCalendars, entityType: .event, eventStore: eventStore), set showsDoneButton = true, showsCancelButton = true
       - Pre-select calendars from selectedCalendarIDs via eventStore.calendar(withIdentifier:)
       - Coordinator implements EKCalendarChooserDelegate:
         - calendarChooserDidFinish: update binding with selected calendar identifiers, dismiss
         - calendarChooserDidCancel: dismiss
       - Wrap in UINavigationController for done/cancel buttons to work

    2. Create TimeQuest/Features/Parent/Views/CalendarSettingsView.swift:
       - Import SwiftUI and EventKit
       - @Environment(AppDependencies.self) private var dependencies
       - @State private var hasAccess: Bool (initialized from calendarService.hasAccess)
       - @State private var selectedCalendarIDs: [String] (initialized from calendarService.selectedCalendarIDs() ?? [])
       - @State private var selectedCalendarNames: [String] (from UserDefaults)
       - @State private var showingCalendarChooser = false
       - Body: Form with sections:
         a. "Calendar Access" section:
            - If hasAccess: green checkmark + "Calendar access granted"
            - If !hasAccess: Button "Enable Calendar Access" that calls requestAccess()
            - Footer: "TimeQuest reads your calendar to detect school days and holidays. Calendar data is never stored."
         b. "School Calendars" section (only if hasAccess):
            - If selectedCalendarIDs not empty: list selected calendar names
            - Button "Select Calendars" that shows CalendarChooserView sheet
            - Footer: "Select the calendars that contain your school schedule. If none selected, all calendars are scanned."
         c. "How It Works" section:
            - Static text explaining: "TimeQuest looks for events like 'No School', 'Holiday', or 'Break' in your calendar. On those days, school-only routines are hidden automatically."
       - requestAccess() method: let granted = await dependencies.calendarService.requestAccess(); hasAccess = granted
       - On calendar chooser dismiss: save selected IDs and names via calendarService

    3. Update TimeQuest/Features/Parent/Views/ParentDashboardView.swift:
       - Add a NavigationLink to CalendarSettingsView in the toolbar or as a list item
       - Best approach: Add a "Calendar" row below the routine list. In the RoutineListView's parent (ParentDashboardView), add a Section or NavigationLink.
       - Since ParentDashboardView shows RoutineListView as its content, add a toolbar item or modify to include a calendar settings link. Simplest: add a NavigationLink in the toolbar's secondary actions or as a dedicated navigation destination.
       - Recommended: Add a Section below RoutineListView content with a NavigationLink("Calendar Settings", destination: CalendarSettingsView()). Since RoutineListView is the body, wrap in a VStack or List, or add navigation destination. Alternatively, add a toolbar button with calendar.badge.clock icon that navigates to CalendarSettingsView.
       - Cleanest approach: Replace the bare RoutineListView() with a List containing RoutineListView's content + a Calendar Settings section. But since RoutineListView is a standalone view, the cleanest is to add a NavigationLink to CalendarSettingsView using .navigationDestination or .toolbar. Use a bottom toolbar item with "Calendar" label + calendar icon, or add it directly.
       - SIMPLEST: Since ParentDashboardView uses NavigationStack, add: .toolbar { ToolbarItem(placement: .bottomBar) { NavigationLink { CalendarSettingsView() } label: { Label("Calendar", systemImage: "calendar.badge.clock") } } }

    4. Update TimeQuest/Features/Parent/Views/RoutineEditorView.swift:
       - Add a new section "Calendar Mode" between scheduleSection and tasksSection
       - Section contains a Picker bound to viewModel.editState calendarModeRaw (or a new @State property if editState doesn't have it yet)
       - Since editState is a value type used by RoutineEditorViewModel, and Routine now has calendarModeRaw, the editState should already carry it. Read RoutineEditorViewModel to confirm.
       - If editState does not include calendarModeRaw yet: add it to the edit state struct in RoutineEditorViewModel, populate from routine.calendarModeRaw in init, and write back to routine on save.
       - Picker options: "Always" (value "always"), "School Days Only" (value "schoolDayOnly"), "Free Days Only" (value "freeDayOnly")
       - Section footer: "Controls when this routine appears based on calendar context"
       - IMPORTANT: Read RoutineEditorViewModel.swift first to understand the edit state pattern before modifying.

    5. Update TimeQuest/Features/Player/Views/PlayerHomeView.swift:
       - Add @State private var dayContext: DayContext = .unknown
       - Modify loadTodayQuests():
         a. Fetch routines as before: let repo = SwiftDataRoutineRepository(...); let allToday = repo.fetchActiveForToday()
         b. Check if calendar service has access: if dependencies.calendarService.hasAccess
         c. If yes: let calendarIDs = dependencies.calendarService.selectedCalendarIDs(); let events = dependencies.calendarService.fetchTodayEvents(from: calendarIDs); let context = CalendarContextEngine().determineContext(events: events, date: .now); dayContext = context
         d. Filter: todayQuests = allToday.filter { CalendarContextEngine().shouldShow(calendarMode: $0.calendarModeRaw, in: dayContext) }
         e. If no calendar access: dayContext = .unknown; todayQuests = allToday (no filtering -- CAL-03)
       - Add a context chip above the quest list (between reflection card and quest list):
         - Only show when dayContext != .unknown AND calendar has access
         - For .schoolDay: HStack with Image(systemName: "backpack.fill") + Text("School day") in a capsule with blue tint
         - For .freeDay(let reason): HStack with Image(systemName: "sun.max.fill") + Text(reason ?? "Free day") in a capsule with orange tint. Truncate reason with lineLimit(1)
         - Style: .font(.caption), .padding(.horizontal, 12), .padding(.vertical, 6), .background(Color.tint.opacity(0.1)), .clipShape(Capsule())
         - CAL-05: passive language only -- "School day", "Free day", "Holiday break" -- NEVER directive ("Time for homework!")

    6. Register new files in generate-xcodeproj.js:
       - sourceFiles: CalendarSettingsView.swift (path: Features/Parent/Views/CalendarSettingsView.swift), CalendarChooserView.swift (path: Features/Parent/Views/CalendarChooserView.swift)
       - ParentViews group: add 'CalendarSettingsView.swift' and 'CalendarChooserView.swift'

    CRITICAL: When calendar access is denied, the app MUST work identically to v2.0. dayContext defaults to .unknown, shouldShow() returns true for all modes when context is .unknown. No error messages, no nag prompts, no broken UI.

    CRITICAL: Calendar data is NEVER persisted. CalendarService.fetchTodayEvents() reads fresh from EventKit each time. Only the calendar IDENTIFIERS (which calendars to scan) are stored in UserDefaults -- not events.

    CRITICAL: Context chip uses passive language per CAL-05. "School day" and "Free day" are observations, not directives.
  </action>
  <verify>
    Run: cd /Users/davezabihaylo/Projects/GSD && node generate-xcodeproj.js && xcodebuild -project TimeQuest.xcodeproj/project.pbxproj -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -5
    Build must succeed with 0 errors. All new files must exist on disk. CalendarSettingsView, CalendarChooserView must be registered in build system. PlayerHomeView must reference CalendarContextEngine and CalendarService.
  </verify>
  <done>
    CalendarService wired into AppDependencies. PlayerHomeView filters routines by DayContext and shows passive context chip. Parent can enable calendar access and select calendars from CalendarSettingsView. Routine editor has calendarMode picker (always/schoolDayOnly/freeDayOnly). Calendar-denied users see no change from v2.0. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with zero errors
2. CalendarService reads fresh EventKit data on each call (no caching or persistence of events)
3. CalendarService is registered in AppDependencies and accessible from views
4. PlayerHomeView applies calendar filtering when access is granted, skips when denied
5. Context chip shows passive language ("School day", "Free day") -- no directive language
6. Parent can toggle calendar access, select calendars, and set routine calendar modes
7. Routine editor includes calendarMode picker with three options
8. Calendar identifiers stored in UserDefaults (device-local), not SwiftData/CloudKit
9. NSCalendarsFullAccessUsageDescription present in build settings
10. App with no calendar access works identically to pre-Phase-8
</verification>

<success_criteria>
- Build passes with all calendar features
- CalendarService follows NotificationManager pattern (@MainActor, async permission, graceful denial)
- PlayerHomeView filters routines by calendar context
- Parent UI enables calendar configuration
- Routine editor has calendarMode picker
- No calendar data persisted to SwiftData (CAL-04)
- No directive language in UI (CAL-05)
- Calendar denial = identical experience to v2.0 (CAL-03)
</success_criteria>

<output>
After completion, create `.planning/phases/08-calendar-intelligence/08-02-SUMMARY.md`
</output>

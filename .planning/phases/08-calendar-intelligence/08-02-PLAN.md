---
phase: 08-calendar-intelligence
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - TimeQuest/Services/CalendarService.swift
  - TimeQuest/App/AppDependencies.swift
  - generate-xcodeproj.js
autonomous: true

must_haves:
  truths:
    - "CalendarService can request and check EventKit full access authorization"
    - "CalendarService fetches today's events and converts them to Sendable CalendarEvent value types"
    - "Calendar data is never stored in SwiftData -- CalendarService reads fresh from EventKit each time"
    - "CalendarService is registered in AppDependencies and accessible from views"
    - "NSCalendarsFullAccessUsageDescription is present in build settings so the app does not crash on permission request"
    - "Selected calendar identifiers are stored in UserDefaults (device-local), not SwiftData/CloudKit"
  artifacts:
    - path: "TimeQuest/Services/CalendarService.swift"
      provides: "EventKit wrapper with permission, event fetching, calendar ID persistence"
      contains: "CalendarService"
    - path: "TimeQuest/App/AppDependencies.swift"
      provides: "CalendarService registered as app dependency"
      contains: "calendarService"
  key_links:
    - from: "TimeQuest/App/AppDependencies.swift"
      to: "TimeQuest/Services/CalendarService.swift"
      via: "CalendarService registered as dependency"
      pattern: "calendarService"
    - from: "TimeQuest/Services/CalendarService.swift"
      to: "TimeQuest/Domain/CalendarContextEngine.swift"
      via: "Returns [CalendarEvent] matching the value type from Plan 01"
      pattern: "CalendarEvent"
    - from: "generate-xcodeproj.js"
      to: "Info.plist"
      via: "INFOPLIST_KEY_NSCalendarsFullAccessUsageDescription build setting"
      pattern: "NSCalendarsFullAccessUsageDescription"
---

<objective>
Create CalendarService (EventKit wrapper) and wire it into AppDependencies with build system configuration.

Purpose: Provides the bridge between Apple's EventKit framework and the pure CalendarContextEngine from Plan 01. After this plan, the app can request calendar permission, fetch today's events, and persist calendar selection preferences -- everything Plan 03 needs to wire into the UI.

Output: CalendarService.swift with permission flow, event fetching, and UserDefaults-based calendar ID persistence. Registered in AppDependencies. NSCalendarsFullAccessUsageDescription in build settings.
</objective>

<execution_context>
@/Users/davezabihaylo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davezabihaylo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-calendar-intelligence/08-RESEARCH.md
@.planning/phases/08-calendar-intelligence/08-01-SUMMARY.md

Key references (read these during execution):
@TimeQuest/Services/NotificationManager.swift - Pattern for @MainActor service with permission flow
@TimeQuest/App/AppDependencies.swift - Where to register CalendarService
@TimeQuest/Domain/CalendarContextEngine.swift - CalendarEvent value type defined here (from Plan 01)
@generate-xcodeproj.js - File and build setting registration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CalendarService EventKit wrapper</name>
  <files>
    TimeQuest/Services/CalendarService.swift
    generate-xcodeproj.js
  </files>
  <action>
    1. Create TimeQuest/Services/CalendarService.swift:
       - Use `@preconcurrency import EventKit` (same pattern as @preconcurrency import UserNotifications in NotificationManager)
       - @MainActor final class CalendarService (follows NotificationManager pattern exactly)
       - Private let eventStore = EKEventStore() (single instance, reused -- research pitfall 2)
       - Properties:
         - var authorizationStatus: EKAuthorizationStatus { EKEventStore.authorizationStatus(for: .event) }
         - var hasAccess: Bool { authorizationStatus == .fullAccess }
       - func requestAccess() async -> Bool:
         - try await eventStore.requestFullAccessToEvents() (iOS 17+ API, NOT the deprecated requestAccess(to:))
         - catch -> return false
       - func fetchTodayEvents(from calendarIdentifiers: [String]? = nil) -> [CalendarEvent]:
         - Guard hasAccess else return []
         - Compute startOfDay and endOfDay for .now
         - If calendarIdentifiers provided, resolve them via eventStore.calendar(withIdentifier:), filter out nil (handles identifier instability -- research pitfall 1)
         - Build predicate with predicateForEvents(withStart:end:calendars:)
         - Fetch events, convert each EKEvent to CalendarEvent value type (from Plan 01's CalendarContextEngine.swift) at the boundary
         - Return [CalendarEvent] -- Sendable value types cross actor boundaries safely
       - func getEventStore() -> EKEventStore { eventStore } -- needed for EKCalendarChooser in Plan 03
       - Static UserDefaults keys:
         - static let selectedCalendarIDsKey = "selectedCalendarIDs"
         - static let selectedCalendarNamesKey = "selectedCalendarNames" (display fallback per research pitfall 1)
       - func selectedCalendarIDs() -> [String]? { UserDefaults.standard.stringArray(forKey: Self.selectedCalendarIDsKey) }
       - func saveSelectedCalendars(ids: [String], names: [String]) { UserDefaults.standard.set(ids, forKey: Self.selectedCalendarIDsKey); UserDefaults.standard.set(names, forKey: Self.selectedCalendarNamesKey) }
       - func clearSelectedCalendars() { UserDefaults.standard.removeObject(forKey: Self.selectedCalendarIDsKey); UserDefaults.standard.removeObject(forKey: Self.selectedCalendarNamesKey) }

    2. Register CalendarService.swift in generate-xcodeproj.js:
       - Add to sourceFiles: { name: 'CalendarService.swift', path: 'Services/CalendarService.swift' }
       - Add to Services group files: 'CalendarService.swift'

    CRITICAL: Use `@preconcurrency import EventKit` to suppress Swift 6 strict concurrency warnings on EKEventStore and EKEvent (non-Sendable Objective-C types). Convert to Sendable CalendarEvent value types immediately after fetch.

    CRITICAL: Calendar identifiers are stored in UserDefaults (device-local), NOT in SwiftData/CloudKit. Calendar IDs are device-specific and would be meaningless on another device (research finding). Also store calendar names as a display fallback for when identifiers become invalid after iCloud sign-out.
  </action>
  <verify>
    Run: cd /Users/davezabihaylo/Projects/GSD && node generate-xcodeproj.js && xcodebuild -project TimeQuest.xcodeproj/project.pbxproj -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -5
    Build must succeed. CalendarService.swift must exist on disk.
  </verify>
  <done>
    CalendarService exists with requestAccess(), fetchTodayEvents(), getEventStore(), and calendar ID persistence in UserDefaults. File registered in build system. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register CalendarService in AppDependencies and add Info.plist calendar permission key</name>
  <files>
    TimeQuest/App/AppDependencies.swift
    generate-xcodeproj.js
  </files>
  <action>
    1. Update TimeQuest/App/AppDependencies.swift:
       - Add `let calendarService: CalendarService` property
       - Initialize in init: self.calendarService = CalendarService()
       - Place after notificationManager (service ordering consistency)

    2. Update generate-xcodeproj.js build settings:
       - Add INFOPLIST_KEY_NSCalendarsFullAccessUsageDescription to BOTH Debug and Release build settings:
         `INFOPLIST_KEY_NSCalendarsFullAccessUsageDescription = "TimeQuest uses your calendar to automatically show the right routines on school days and hide them on holidays.";`
         Add this line after the existing INFOPLIST_KEY_UIBackgroundModes line in both build config sections.

    CRITICAL: Without the NSCalendarsFullAccessUsageDescription Info.plist key, calling requestFullAccessToEvents() will crash at runtime. This MUST be in both Debug and Release build settings.
  </action>
  <verify>
    Run: cd /Users/davezabihaylo/Projects/GSD && node generate-xcodeproj.js && xcodebuild -project TimeQuest.xcodeproj/project.pbxproj -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -5
    Build must succeed. AppDependencies must have calendarService property. grep for NSCalendarsFullAccessUsageDescription in generate-xcodeproj.js must find it.
  </verify>
  <done>
    CalendarService registered in AppDependencies. NSCalendarsFullAccessUsageDescription present in both Debug and Release build settings. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with zero errors
2. CalendarService.swift exists with @MainActor, EKEventStore reuse, async requestAccess(), fetchTodayEvents()
3. CalendarService returns [CalendarEvent] value types (matching Plan 01's type), never raw EKEvent
4. CalendarService is registered in AppDependencies and accessible from views
5. NSCalendarsFullAccessUsageDescription present in both Debug and Release build settings
6. Calendar identifiers stored in UserDefaults (device-local), not SwiftData/CloudKit
7. No calendar data persistence -- fetchTodayEvents() reads fresh from EventKit each time
</verification>

<success_criteria>
- Build passes with CalendarService and AppDependencies changes
- CalendarService follows NotificationManager pattern (@MainActor, async permission, graceful denial)
- EventKit types converted to Sendable CalendarEvent at the boundary
- Info.plist calendar permission key configured in build settings
- Selected calendar IDs persisted in UserDefaults only
</success_criteria>

<output>
After completion, create `.planning/phases/08-calendar-intelligence/08-02-SUMMARY.md`
</output>

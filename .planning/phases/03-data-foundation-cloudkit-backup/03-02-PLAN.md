---
phase: 03-data-foundation-cloudkit-backup
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - TimeQuest/App/TimeQuestApp.swift
  - TimeQuest/App/AppDependencies.swift
  - TimeQuest/Services/CloudKitSyncMonitor.swift
  - TimeQuest/Repositories/SessionRepository.swift
  - TimeQuest/Repositories/PlayerProfileRepository.swift
  - TimeQuest/Features/Player/Views/NotificationSettingsView.swift
  - TimeQuest/TimeQuest.entitlements
  - generate-xcodeproj.js
autonomous: false

user_setup:
  - service: iCloud/CloudKit
    why: "CloudKit container must be registered with Apple Developer account"
    dashboard_config:
      - task: "Enable iCloud capability and create CloudKit container"
        location: "Xcode -> Target -> Signing & Capabilities -> + Capability -> iCloud -> check CloudKit -> create container iCloud.com.timequest.app"

must_haves:
  truths:
    - "App initializes ModelContainer with migration plan and CloudKit database configuration"
    - "PlayerProfile singleton uses sentinel cloudID pattern to prevent CloudKit duplication"
    - "SessionRepository queries use cloudID instead of persistentModelID"
    - "Settings screen shows iCloud backup status (synced/syncing/no account/error)"
    - "Entitlements file enables iCloud + CloudKit services"
    - "All existing v1.0 features work identically after migration"
  artifacts:
    - path: "TimeQuest/Services/CloudKitSyncMonitor.swift"
      provides: "Observable sync status monitor using NSPersistentCloudKitContainer events"
      contains: "CloudKitSyncMonitor"
    - path: "TimeQuest/TimeQuest.entitlements"
      provides: "iCloud + CloudKit entitlements plist"
      contains: "com.apple.developer.icloud-services"
    - path: "TimeQuest/App/TimeQuestApp.swift"
      provides: "ModelContainer init with migration plan + CloudKit config"
      contains: "TimeQuestMigrationPlan"
    - path: "TimeQuest/Repositories/SessionRepository.swift"
      provides: "cloudID-based queries instead of persistentModelID"
      contains: "cloudID"
    - path: "TimeQuest/Repositories/PlayerProfileRepository.swift"
      provides: "Singleton deduplication with sentinel cloudID"
      contains: "singleton-player-profile"
    - path: "TimeQuest/Features/Player/Views/NotificationSettingsView.swift"
      provides: "iCloud backup status section in settings"
      contains: "CloudKitSyncMonitor"
  key_links:
    - from: "TimeQuest/App/TimeQuestApp.swift"
      to: "TimeQuestMigrationPlan + ModelConfiguration"
      via: "ModelContainer init with migration plan and cloudKitDatabase"
      pattern: "cloudKitDatabase.*\\.automatic"
    - from: "TimeQuest/Services/CloudKitSyncMonitor.swift"
      to: "NSPersistentCloudKitContainer.eventChangedNotification"
      via: "NotificationCenter observer"
      pattern: "eventChangedNotification"
    - from: "TimeQuest/Repositories/SessionRepository.swift"
      to: "Routine.cloudID"
      via: "Predicate query on cloudID"
      pattern: "cloudID"
    - from: "TimeQuest/App/AppDependencies.swift"
      to: "CloudKitSyncMonitor"
      via: "Dependency injection"
      pattern: "CloudKitSyncMonitor"
---

<objective>
Enable CloudKit sync, configure entitlements, update ModelContainer initialization with migration plan, migrate repository queries to cloudID, add PlayerProfile deduplication, and build a backup status indicator in settings.

Purpose: Protects all player data against device loss via iCloud backup. Without this, a phone replacement means losing all XP, levels, streaks, and session history -- devastating for a player who has been training for weeks.

Output: 1 new Swift file (CloudKitSyncMonitor), 1 entitlements file, 5 updated Swift files, updated build script.
</objective>

<execution_context>
@/Users/davezabihaylo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/davezabihaylo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-foundation-cloudkit-backup/03-RESEARCH.md
@.planning/phases/03-data-foundation-cloudkit-backup/03-01-SUMMARY.md

@TimeQuest/App/TimeQuestApp.swift
@TimeQuest/App/AppDependencies.swift
@TimeQuest/Repositories/SessionRepository.swift
@TimeQuest/Repositories/PlayerProfileRepository.swift
@TimeQuest/Features/Player/Views/NotificationSettingsView.swift
@generate-xcodeproj.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create entitlements, sync monitor, update app init + repositories</name>
  <files>
    TimeQuest/TimeQuest.entitlements
    TimeQuest/Services/CloudKitSyncMonitor.swift
    TimeQuest/App/TimeQuestApp.swift
    TimeQuest/App/AppDependencies.swift
    TimeQuest/Repositories/SessionRepository.swift
    TimeQuest/Repositories/PlayerProfileRepository.swift
  </files>
  <action>
**TimeQuest.entitlements** -- Create at `TimeQuest/TimeQuest.entitlements`:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.developer.icloud-services</key>
    <array>
        <string>CloudKit</string>
    </array>
    <key>com.apple.developer.icloud-container-identifiers</key>
    <array>
        <string>iCloud.com.timequest.app</string>
    </array>
    <key>aps-environment</key>
    <string>development</string>
</dict>
</plist>
```

**CloudKitSyncMonitor.swift** -- Create at `TimeQuest/Services/CloudKitSyncMonitor.swift`.
An @Observable @MainActor class that tracks CloudKit sync status. Uses `NSPersistentCloudKitContainer.eventChangedNotification` to monitor sync events and `CKContainer.accountStatus()` for iCloud availability.

```swift
import Foundation
import CloudKit
import CoreData  // For NSPersistentCloudKitContainer.Event

@MainActor @Observable
final class CloudKitSyncMonitor {
    enum SyncStatus: Equatable {
        case notStarted
        case syncing
        case synced(Date)
        case error(String)
        case noAccount

        // Display text for settings UI
        var displayText: String {
            switch self {
            case .notStarted: return "Waiting..."
            case .syncing: return "Syncing..."
            case .synced(let date):
                let formatter = RelativeDateTimeFormatter()
                formatter.unitsStyle = .abbreviated
                return "Synced \(formatter.localizedString(for: date, relativeTo: Date.now))"
            case .error(let msg): return "Error: \(msg)"
            case .noAccount: return "iCloud not available"
            }
        }

        var systemImage: String {
            switch self {
            case .notStarted: return "icloud"
            case .syncing: return "arrow.triangle.2.circlepath.icloud"
            case .synced: return "checkmark.icloud"
            case .error: return "exclamationmark.icloud"
            case .noAccount: return "icloud.slash"
            }
        }

        // Equatable conformance for cases with associated values
        static func == (lhs: SyncStatus, rhs: SyncStatus) -> Bool {
            switch (lhs, rhs) {
            case (.notStarted, .notStarted): return true
            case (.syncing, .syncing): return true
            case (.synced(let a), .synced(let b)): return a == b
            case (.error(let a), .error(let b)): return a == b
            case (.noAccount, .noAccount): return true
            default: return false
            }
        }
    }

    var status: SyncStatus = .notStarted
    private var observer: NSObjectProtocol?

    func startMonitoring() {
        // Listen for CloudKit sync events
        observer = NotificationCenter.default.addObserver(
            forName: NSPersistentCloudKitContainer.eventChangedNotification,
            object: nil, queue: .main
        ) { [weak self] notification in
            Task { @MainActor in
                guard let self else { return }
                guard let event = notification.userInfo?[
                    NSPersistentCloudKitContainer.eventNotificationUserInfoKey
                ] as? NSPersistentCloudKitContainer.Event else { return }

                if event.endDate != nil {
                    if let error = event.error {
                        self.status = .error(error.localizedDescription)
                    } else {
                        self.status = .synced(event.endDate ?? Date())
                    }
                } else {
                    self.status = .syncing
                }
            }
        }

        // Check iCloud account availability
        Task {
            do {
                let accountStatus = try await CKContainer.default().accountStatus()
                if accountStatus != .available {
                    self.status = .noAccount
                }
            } catch {
                self.status = .noAccount
            }
        }
    }

    deinit {
        if let observer { NotificationCenter.default.removeObserver(observer) }
    }
}
```

Use `@preconcurrency import CoreData` if the compiler warns about NSPersistentCloudKitContainer.Event not being Sendable. The `deinit` cannot be @MainActor, so guard the observer removal carefully -- since observer is set on MainActor and removeObserver is thread-safe, this is fine.

**TimeQuestApp.swift** -- Replace the `.modelContainer(for:)` modifier approach with explicit ModelContainer initialization using migration plan + CloudKit config.

```swift
import SwiftUI
import SwiftData

@main
struct TimeQuestApp: App {
    let container: ModelContainer

    init() {
        do {
            let config = ModelConfiguration(
                cloudKitDatabase: .automatic
            )
            container = try ModelContainer(
                for: TimeQuestSchemaV2.Routine.self,
                     TimeQuestSchemaV2.RoutineTask.self,
                     TimeQuestSchemaV2.GameSession.self,
                     TimeQuestSchemaV2.TaskEstimation.self,
                     TimeQuestSchemaV2.PlayerProfile.self,
                migrationPlan: TimeQuestMigrationPlan.self,
                configurations: config
            )
        } catch {
            fatalError("Failed to initialize model container: \(error)")
        }
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(container)
    }
}
```

Keep the existing `ContentView` private struct that creates `AppDependencies` from `modelContext`.

**AppDependencies.swift** -- Add `CloudKitSyncMonitor` as a dependency:
- Add `let syncMonitor: CloudKitSyncMonitor` property
- Initialize it in `init(modelContext:)`: `self.syncMonitor = CloudKitSyncMonitor()` then call `syncMonitor.startMonitoring()`

**SessionRepository.swift** -- Replace `persistentModelID` predicate with `cloudID`:
```swift
func fetchSessions(for routine: Routine) -> [GameSession] {
    let routineCloudID = routine.cloudID
    let descriptor = FetchDescriptor<GameSession>(
        predicate: #Predicate { $0.routine?.cloudID == routineCloudID },
        sortBy: [SortDescriptor(\.startedAt, order: .reverse)]
    )
    return (try? modelContext.fetch(descriptor)) ?? []
}
```

**PlayerProfileRepository.swift** -- Update `fetchOrCreate()` with sentinel cloudID deduplication:
```swift
func fetchOrCreate() -> PlayerProfile {
    let descriptor = FetchDescriptor<PlayerProfile>(
        sortBy: [SortDescriptor(\.createdAt)]
    )
    let allProfiles = (try? modelContext.fetch(descriptor)) ?? []

    if allProfiles.isEmpty {
        let profile = PlayerProfile()
        profile.cloudID = "singleton-player-profile"
        modelContext.insert(profile)
        return profile
    }

    // Deduplication: keep first, merge extras (handles CloudKit sync creating duplicates)
    let keeper = allProfiles[0]
    if keeper.cloudID != "singleton-player-profile" {
        keeper.cloudID = "singleton-player-profile"
    }
    for extra in allProfiles.dropFirst() {
        keeper.totalXP = max(keeper.totalXP, extra.totalXP)
        keeper.currentStreak = max(keeper.currentStreak, extra.currentStreak)
        if let extraDate = extra.lastPlayedDate,
           let keeperDate = keeper.lastPlayedDate,
           extraDate > keeperDate {
            keeper.lastPlayedDate = extraDate
        } else if extra.lastPlayedDate != nil && keeper.lastPlayedDate == nil {
            keeper.lastPlayedDate = extra.lastPlayedDate
        }
        modelContext.delete(extra)
    }
    try? modelContext.save()
    return keeper
}
```

Also remove the `fetchLimit = 1` from the old implementation -- we need to fetch all to deduplicate.
  </action>
  <verify>
All files exist. Run `xcodebuild -project TimeQuest/TimeQuest.xcodeproj -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20` -- project must compile. Verify `grep "cloudKitDatabase" TimeQuest/App/TimeQuestApp.swift` shows CloudKit config. Verify `grep "singleton-player-profile" TimeQuest/Repositories/PlayerProfileRepository.swift` shows deduplication. Verify `grep "cloudID" TimeQuest/Repositories/SessionRepository.swift` shows updated query.
  </verify>
  <done>
ModelContainer initializes with migration plan + CloudKit. CloudKitSyncMonitor tracks sync events. SessionRepository uses cloudID queries. PlayerProfileRepository has sentinel deduplication. Entitlements file exists with iCloud + CloudKit keys.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add backup status to settings UI + update build system</name>
  <files>
    TimeQuest/Features/Player/Views/NotificationSettingsView.swift
    generate-xcodeproj.js
  </files>
  <action>
**NotificationSettingsView.swift** -- Add an "iCloud Backup" section at the top of the Form, before the existing "Notifications" section.

The view needs access to `CloudKitSyncMonitor` from `AppDependencies`. Add a new property:
```swift
let syncMonitor: CloudKitSyncMonitor
```

Add this section at the top of the Form body:
```swift
Section("iCloud Backup") {
    HStack {
        Image(systemName: syncMonitor.status.systemImage)
            .foregroundStyle(statusColor)
            .imageScale(.large)
        VStack(alignment: .leading, spacing: 2) {
            Text("iCloud Backup")
                .font(.body)
            Text(syncMonitor.status.displayText)
                .font(.caption)
                .foregroundStyle(.secondary)
        }
        Spacer()
    }
    .padding(.vertical, 4)
}
```

Add a computed `statusColor` property:
```swift
private var statusColor: Color {
    switch syncMonitor.status {
    case .synced: return .green
    case .syncing: return .blue
    case .error: return .red
    case .noAccount: return .orange
    case .notStarted: return .gray
    }
}
```

Update ALL call sites that create `NotificationSettingsView` to pass `syncMonitor`. Search for `NotificationSettingsView(` in the codebase -- it's called from PlayerHomeView or PlayerStatsView. Add the `syncMonitor: dependencies.syncMonitor` parameter at each call site.

**generate-xcodeproj.js** -- Add remaining new files:

1. Add to `sourceFiles` array:
   - `{ name: 'CloudKitSyncMonitor.swift', path: 'Services/CloudKitSyncMonitor.swift' }`

2. Add `'CloudKitSyncMonitor.swift'` to the Services group's files array (the group named 'Services').

3. Add entitlements file reference. Since the entitlements file is NOT a source file (it's a build setting reference, not compiled), add it as a file reference but NOT to the sources build phase. Add a new PBXFileReference entry for `TimeQuest.entitlements` with `lastKnownFileType = text.plist.entitlements`. The simplest approach: add it to the `sourceFiles` array conceptually but actually create a separate array or handle it specially. Since the build script is straightforward, the cleanest approach is:
   - Add a `fileRef` entry manually in the `fileRefs` string construction loop for `TimeQuest.entitlements`
   - Do NOT add a build file for it (it's not compiled)
   - Add `CODE_SIGN_ENTITLEMENTS = TimeQuest/TimeQuest.entitlements;` to BOTH debug and release TARGET build settings (the `debugConfigTarget` and `releaseConfigTarget` sections)

4. Add `UIBackgroundModes` with `remote-notification` to Info.plist keys in the target build settings:
   - Add `INFOPLIST_KEY_UIBackgroundModes = "remote-notification";` to both debug and release target build settings

5. Run `node generate-xcodeproj.js` to regenerate.

6. Run `xcodebuild build` to verify everything compiles.
  </action>
  <verify>
Run `node generate-xcodeproj.js` -- succeeds. Run `xcodebuild -project TimeQuest/TimeQuest.xcodeproj -scheme TimeQuest -destination 'platform=iOS Simulator,name=iPhone 16' build 2>&1 | tail -20` -- compiles with zero errors. Verify `grep "iCloud Backup" TimeQuest/Features/Player/Views/NotificationSettingsView.swift` shows the new section. Verify `grep "CODE_SIGN_ENTITLEMENTS" TimeQuest/TimeQuest.xcodeproj/project.pbxproj` shows entitlements reference. Verify `grep "CloudKitSyncMonitor" generate-xcodeproj.js` shows the file is registered.
  </verify>
  <done>
Settings screen shows iCloud backup status section with sync status icon and text. Build system registers CloudKitSyncMonitor.swift and entitlements file. CODE_SIGN_ENTITLEMENTS and UIBackgroundModes set in target build settings. Project compiles successfully.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify settings UI shows backup status + CloudKit container setup</name>
  <files>TimeQuest/Features/Player/Views/NotificationSettingsView.swift</files>
  <action>
Human verification checkpoint. What was built: Complete CloudKit backup integration -- schema versioning with V1/V2, lightweight migration, CloudKit-enabled ModelContainer, sync monitor, cloudID-based queries, PlayerProfile deduplication, backup status in settings UI, and entitlements configuration.

How to verify:
1. Open the project in Xcode: `open TimeQuest/TimeQuest.xcodeproj`
2. In Xcode, go to Target -> Signing and Capabilities
3. Click "+ Capability" -> add "iCloud"
4. Check the "CloudKit" checkbox
5. Create or select the container "iCloud.com.timequest.app"
6. Build and run on Simulator (iPhone 16)
7. Navigate to Settings (from Player Home)
8. VERIFY: "iCloud Backup" section appears at the top with a status icon and text
9. If not signed into iCloud on simulator, expect "iCloud not available" status
10. If signed in, expect "Syncing..." or "Synced" status after a moment
11. VERIFY: All existing features still work: navigate to a quest, start estimation game, check stats
12. VERIFY: No console errors related to migration or schema mismatch
  </action>
  <verify>User confirms settings UI shows backup status and all v1.0 features work after migration.</verify>
  <done>User approves: settings show iCloud backup status, app runs without crashes, existing features work identically.</done>
</task>

</tasks>

<verification>
1. `ls TimeQuest/TimeQuest.entitlements` -- entitlements file exists
2. `ls TimeQuest/Services/CloudKitSyncMonitor.swift` -- sync monitor exists
3. `grep "cloudKitDatabase" TimeQuest/App/TimeQuestApp.swift` -- CloudKit config present
4. `grep "TimeQuestMigrationPlan" TimeQuest/App/TimeQuestApp.swift` -- migration plan wired
5. `grep "singleton-player-profile" TimeQuest/Repositories/PlayerProfileRepository.swift` -- deduplication present
6. `grep "cloudID" TimeQuest/Repositories/SessionRepository.swift` -- cloudID query present
7. `grep "iCloud Backup" TimeQuest/Features/Player/Views/NotificationSettingsView.swift` -- UI section present
8. `grep "CODE_SIGN_ENTITLEMENTS" TimeQuest/TimeQuest.xcodeproj/project.pbxproj` -- build setting present
9. `xcodebuild build` succeeds
</verification>

<success_criteria>
- ModelContainer initializes with TimeQuestMigrationPlan and cloudKitDatabase: .automatic
- CloudKitSyncMonitor tracks sync events via NSPersistentCloudKitContainer.eventChangedNotification
- SessionRepository uses cloudID instead of persistentModelID in predicates
- PlayerProfileRepository uses sentinel cloudID "singleton-player-profile" with deduplication logic
- Settings screen shows "iCloud Backup" section with status (synced/syncing/error/no account)
- Entitlements file has iCloud + CloudKit + aps-environment keys
- Build system includes CODE_SIGN_ENTITLEMENTS and UIBackgroundModes settings
- Project compiles and runs with all v1.0 features working
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-foundation-cloudkit-backup/03-02-SUMMARY.md`
</output>
